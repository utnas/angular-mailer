define("htmlbars-syntax-tests/htmlbars-syntax.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests');
    test('htmlbars-syntax-tests/htmlbars-syntax.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/builders.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/builders.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/builders.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/node-handlers.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/node-handlers.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/node-handlers.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/parser.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/parser.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/parser.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/token-handlers.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/token-handlers.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/token-handlers.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/tokenizer.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/tokenizer.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/tokenizer.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/utils.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/utils.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/utils.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/htmlbars-syntax/walker.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests/htmlbars-syntax');
    test('htmlbars-syntax-tests/htmlbars-syntax/walker.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/htmlbars-syntax/walker.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/parser-node-test",
  ["../htmlbars-syntax/handlebars/compiler/base","../htmlbars-syntax/parser","../htmlbars-syntax/builders"],
  function(__dependency1__, __dependency2__, __dependency3__) {
    "use strict";
    var parse = __dependency1__.parse;
    var preprocess = __dependency2__.preprocess;

    var b = __dependency3__["default"];

    QUnit.module("HTML-based compiler (AST)");

    function normalizeNode(obj) {
      if (obj && typeof obj === 'object') {
        var newObj;
        if (obj.splice) {
          newObj = new Array(obj.length);

          for (var i = 0; i < obj.length; i++) {
            newObj[i] = normalizeNode(obj[i]);
          }
        } else {
          newObj = {};

          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              newObj[key] = normalizeNode(obj[key]);
            }
          }

          if (newObj.type) {
            newObj._type = newObj.type;
            delete newObj.type;
          }

          if (newObj.loc) {
            delete newObj.loc;
          }
        }
        return newObj;
      } else {
        return obj;
      }

    }

    function astEqual(actual, expected, message) {
      // Perform a deepEqual but recursively remove the locInfo stuff
      // (e.g. line/column information about the compiled template)
      // that we don't want to have to write into our test cases.

      if (typeof actual === 'string') {
        actual = preprocess(actual);
      }
      if (typeof expected === 'string') {
        expected = preprocess(expected);
      }

      actual = normalizeNode(actual);
      expected = normalizeNode(expected);

      deepEqual(actual, expected, message);
    }

    test("a simple piece of content", function() {
      var t = 'some content';
      astEqual(t, b.program([
        b.text('some content')
      ]));
    });

    test("allow simple AST to be passed", function() {
      var ast = preprocess(parse("simple"));

      astEqual(ast, b.program([
        b.text("simple")
      ]));
    });

    test("allow an AST with mustaches to be passed", function() {
      var ast = preprocess(parse("<h1>some</h1> ast {{foo}}"));

      astEqual(ast, b.program([
        b.element("h1", [], [], [
          b.text("some")
        ]),
        b.text(" ast "),
        b.mustache(b.sexpr(b.path('foo')))
      ]));
    });

    test("self-closed element", function() {
      var t = '<g />';
      astEqual(t, b.program([
        b.element("g")
      ]));
    });

    test("elements can have empty attributes", function() {
      var t = '<img id="">';
      astEqual(t, b.program([
        b.element("img", [
          b.attr("id", b.text(""))
        ])
      ]));
    });

    test("svg content", function() {
      var t = "<svg></svg>";
      astEqual(t, b.program([
        b.element("svg")
      ]));
    });

    test("html content with html content inline", function() {
      var t = '<div><p></p></div>';
      astEqual(t, b.program([
        b.element("div", [], [], [
          b.element("p")
        ])
      ]));
    });

    test("html content with svg content inline", function() {
      var t = '<div><svg></svg></div>';
      astEqual(t, b.program([
        b.element("div", [], [], [
          b.element("svg")
        ])
      ]));
    });

    var integrationPoints = ['foreignObject', 'desc', 'title'];
    function buildIntegrationPointTest(integrationPoint){
      return function integrationPointTest(){
        var t = '<svg><'+integrationPoint+'><div></div></'+integrationPoint+'></svg>';
        astEqual(t, b.program([
          b.element("svg", [], [], [
            b.element(integrationPoint, [], [], [
              b.element("div")
            ])
          ])
        ]));
      };
    }
    for (var i=0, length = integrationPoints.length; i<length; i++) {
      test(
        "svg content with html content inline for "+integrationPoints[i],
        buildIntegrationPointTest(integrationPoints[i])
      );
    }

    test("a piece of content with HTML", function() {
      var t = 'some <div>content</div> done';
      astEqual(t, b.program([
        b.text("some "),
        b.element("div", [], [], [
          b.text("content")
        ]),
        b.text(" done")
      ]));
    });

    test("a piece of Handlebars with HTML", function() {
      var t = 'some <div>{{content}}</div> done';
      astEqual(t, b.program([
        b.text("some "),
        b.element("div", [], [], [
          b.mustache(b.sexpr(b.path('content')))
        ]),
        b.text(" done")
      ]));
    });

    test("Handlebars embedded in an attribute (quoted)", function() {
      var t = 'some <div class="{{foo}}">content</div> done';
      astEqual(t, b.program([
        b.text("some "),
        b.element("div", [ b.attr("class", b.concat([ b.path('foo') ])) ], [], [
          b.text("content")
        ]),
        b.text(" done")
      ]));
    });

    test("Handlebars embedded in an attribute (unquoted)", function() {
      var t = 'some <div class={{foo}}>content</div> done';
      astEqual(t, b.program([
        b.text("some "),
        b.element("div", [ b.attr("class", b.mustache(b.sexpr(b.path('foo')))) ], [], [
          b.text("content")
        ]),
        b.text(" done")
      ]));
    });

    test("Handlebars embedded in an attribute (sexprs)", function() {
      var t = 'some <div class="{{foo (foo "abc")}}">content</div> done';
      astEqual(t, b.program([
        b.text("some "),
        b.element("div", [
          b.attr("class", b.concat([ b.sexpr(b.path('foo'), [ b.sexpr(b.path('foo'), [ b.string('abc') ]) ]) ]))
        ], [], [
          b.text("content")
        ]),
        b.text(" done")
      ]));
    });


    test("Handlebars embedded in an attribute with other content surrounding it", function() {
      var t = 'some <a href="http://{{link}}/">content</a> done';
      astEqual(t, b.program([
        b.text("some "),
        b.element("a", [
          b.attr("href", b.concat([
            b.string("http://"),
            b.path('link'),
            b.string("/")
          ]))
        ], [], [
          b.text("content")
        ]),
        b.text(" done")
      ]));
    });

    test("A more complete embedding example", function() {
      var t = "{{embed}} {{some 'content'}} " +
              "<div class='{{foo}} {{bind-class isEnabled truthy='enabled'}}'>{{ content }}</div>" +
              " {{more 'embed'}}";
      astEqual(t, b.program([
        b.mustache(b.sexpr(b.path('embed'))),
        b.text(' '),
        b.mustache(b.sexpr(b.path('some'), [b.string('content')])),
        b.text(' '),
        b.element("div", [
          b.attr("class", b.concat([
            b.path('foo'),
            b.string(' '),
            b.sexpr(b.path('bind-class'), [b.path('isEnabled')], b.hash([b.pair('truthy', b.string('enabled'))]))
          ]))
        ], [], [
          b.mustache(b.sexpr(b.path('content')))
        ]),
        b.text(' '),
        b.mustache(b.sexpr(b.path('more'), [b.string('embed')]))
      ]));
    });

    test("Simple embedded block helpers", function() {
      var t = "{{#if foo}}<div>{{content}}</div>{{/if}}";
      astEqual(t, b.program([
        b.block(b.sexpr(b.path('if'), [b.path('foo')]), b.program([
          b.element('div', [], [], [
            b.mustache(b.sexpr(b.path('content')))
          ])
        ]))
      ]));
    });

    test("Involved block helper", function() {
      var t = '<p>hi</p> content {{#testing shouldRender}}<p>Appears!</p>{{/testing}} more <em>content</em> here';
      astEqual(t, b.program([
        b.element('p', [], [], [
          b.text('hi')
        ]),
        b.text(' content '),
        b.block(b.sexpr(b.path('testing'), [b.path('shouldRender')]), b.program([
          b.element('p', [], [], [
            b.text('Appears!')
          ])
        ])),
        b.text(' more '),
        b.element('em', [], [], [
          b.text('content')
        ]),
        b.text(' here')
      ]));
    });

    test("Node helpers", function() {
      var t = "<p {{action 'boom'}} class='bar'>Some content</p>";
      astEqual(t, b.program([
        b.element('p', [ b.attr('class', b.text('bar')) ], [b.sexpr(b.path('action'), [b.string('boom')])], [
          b.text('Some content')
        ])
      ]));
    });

    test("Tokenizer: MustacheStatement encountered in tagName state", function() {
      var t = "<input{{bar}}>";
      astEqual(t, b.program([
        b.element('input', [], [ b.sexpr(b.path('bar')) ])
      ]));
    });

    test("Tokenizer: MustacheStatement encountered in beforeAttributeName state", function() {
      var t = "<input {{bar}}>";
      astEqual(t, b.program([
        b.element('input', [], [ b.sexpr(b.path('bar')) ])
      ]));
    });

    test("Tokenizer: MustacheStatement encountered in attributeName state", function() {
      var t = "<input foo{{bar}}>";
      astEqual(t, b.program([
        b.element('input', [ b.attr('foo', b.text('')) ], [ b.sexpr(b.path('bar')) ])
      ]));
    });

    test("Tokenizer: MustacheStatement encountered in afterAttributeName state", function() {
      var t = "<input foo {{bar}}>";
      astEqual(t, b.program([
        b.element('input', [ b.attr('foo', b.text('')) ], [ b.sexpr(b.path('bar')) ])
      ]));
    });

    test("Tokenizer: MustacheStatement encountered in afterAttributeValue state", function() {
      var t = "<input foo=1 {{bar}}>";
      astEqual(t, b.program([
        b.element('input', [ b.attr('foo', b.text('1')) ], [ b.sexpr(b.path('bar')) ])
      ]));
    });

    test("Tokenizer: MustacheStatement encountered in afterAttributeValueQuoted state", function() {
      var t = "<input foo='1'{{bar}}>";
      astEqual(t, b.program([
        b.element('input', [ b.attr('foo', b.text('1')) ], [ b.sexpr(b.path('bar')) ])
      ]));
    });

    test("Stripping - mustaches", function() {
      var t = "foo {{~content}} bar";
      astEqual(t, b.program([
        b.text('foo'),
        b.mustache(b.sexpr(b.path('content'))),
        b.text(' bar')
      ]));

      t = "foo {{content~}} bar";
      astEqual(t, b.program([
        b.text('foo '),
        b.mustache(b.sexpr(b.path('content'))),
        b.text('bar')
      ]));
    });

    test("Stripping - blocks", function() {
      var t = "foo {{~#wat}}{{/wat}} bar";
      astEqual(t, b.program([
        b.text('foo'),
        b.block(b.sexpr(b.path('wat')), b.program()),
        b.text(' bar')
      ]));

      t = "foo {{#wat}}{{/wat~}} bar";
      astEqual(t, b.program([
        b.text('foo '),
        b.block(b.sexpr(b.path('wat')), b.program()),
        b.text('bar')
      ]));
    });


    test("Stripping - programs", function() {
      var t = "{{#wat~}} foo {{else}}{{/wat}}";
      astEqual(t, b.program([
        b.block(b.sexpr(b.path('wat')), b.program([
          b.text('foo ')
        ]), b.program())
      ]));

      t = "{{#wat}} foo {{~else}}{{/wat}}";
      astEqual(t, b.program([
        b.block(b.sexpr(b.path('wat')), b.program([
          b.text(' foo')
        ]), b.program())
      ]));

      t = "{{#wat}}{{else~}} foo {{/wat}}";
      astEqual(t, b.program([
        b.block(b.sexpr(b.path('wat')), b.program(), b.program([
          b.text('foo ')
        ]))
      ]));

      t = "{{#wat}}{{else}} foo {{~/wat}}";
      astEqual(t, b.program([
        b.block(b.sexpr(b.path('wat')), b.program(), b.program([
          b.text(' foo')
        ]))
      ]));
    });

    test("Stripping - removes unnecessary text nodes", function() {
      var t = "{{#each~}}\n  <li> foo </li>\n{{~/each}}";
      astEqual(t, b.program([
        b.block(b.sexpr(b.path('each')), b.program([
          b.element('li', [], [], [b.text(' foo ')])
        ]))
      ]));
    });

    // TODO: Make these throw an error.
    //test("Awkward mustache in unquoted attribute value", function() {
    //  var t = "<div class=a{{foo}}></div>";
    //  astEqual(t, b.program([
    //    b.element('div', [ b.attr('class', concat([b.string("a"), b.sexpr([b.path('foo')])])) ])
    //  ]));
    //
    //  t = "<div class=a{{foo}}b></div>";
    //  astEqual(t, b.program([
    //    b.element('div', [ b.attr('class', concat([b.string("a"), b.sexpr([b.path('foo')]), b.string("b")])) ])
    //  ]));
    //
    //  t = "<div class={{foo}}b></div>";
    //  astEqual(t, b.program([
    //    b.element('div', [ b.attr('class', concat([b.sexpr([b.path('foo')]), b.string("b")])) ])
    //  ]));
    //});

    test("Components", function() {
      var t = "<x-foo a=b c='d' e={{f}} id='{{bar}}' class='foo-{{bar}}'>{{a}}{{b}}c{{d}}</x-foo>{{e}}";
      astEqual(t, b.program([
        b.component('x-foo', [
          b.attr('a', b.text('b')),
          b.attr('c', b.text('d')),
          b.attr('e', b.mustache(b.sexpr(b.path('f')))),
          b.attr('id', b.concat([ b.path('bar') ])),
          b.attr('class', b.concat([ b.string('foo-'), b.path('bar') ]))
        ], b.program([
          b.mustache(b.sexpr(b.path('a'))),
          b.mustache(b.sexpr(b.path('b'))),
          b.text('c'),
          b.mustache(b.sexpr(b.path('d')))
        ])),
        b.mustache(b.sexpr(b.path('e')))
      ]));
    });

    test("Components with disableComponentGeneration", function() {
      var t = "begin <x-foo>content</x-foo> finish";
      var actual = preprocess(t, {
        disableComponentGeneration: true
      });

      astEqual(actual, b.program([
        b.text("begin "),
        b.element("x-foo", [], [], [
          b.text("content")
        ]),
        b.text(" finish")
      ]));
    });

    test("Components with disableComponentGeneration === false", function() {
      var t = "begin <x-foo>content</x-foo> finish";
      var actual = preprocess(t, {
        disableComponentGeneration: false
      });

      astEqual(actual, b.program([
        b.text("begin "),
        b.component("x-foo", [],
          b.program([
            b.text("content")
          ])
        ),
        b.text(" finish")
      ]));
    });

    test("an HTML comment", function() {
      var t = 'before <!-- some comment --> after';
      astEqual(t, b.program([
        b.text("before "),
        b.comment(" some comment "),
        b.text(" after")
      ]));
    });
  });
define("htmlbars-syntax-tests/parser-node-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests');
    test('htmlbars-syntax-tests/parser-node-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/parser-node-test.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/plugin-node-test",
  ["../htmlbars-syntax/walker","../htmlbars-syntax/parser"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var Walker = __dependency1__["default"];
    var preprocess = __dependency2__.preprocess;

    QUnit.module('Compiler plugins: AST');


    test('AST plugins can be provided to the compiler', function() {
      expect(1);

      function Plugin() { }
      Plugin.prototype.transform = function() {
        ok(true, 'transform was called!');
      };

      preprocess('<div></div>', {
        plugins: {
          ast: [ Plugin ]
        }
      });
    });

    test('provides syntax package as `syntax` prop if value is null', function() {
      expect(1);

      function Plugin() { }
      Plugin.prototype.transform = function() {
        equal(this.syntax.Walker, Walker);
      };

      preprocess('<div></div>', {
        plugins: {
          ast: [ Plugin ]
        }
      });
    });

    test('AST plugins can modify the AST', function() {
      expect(1);

      var expected = "OOOPS, MESSED THAT UP!";

      function Plugin() { }
      Plugin.prototype.transform = function() {
        return expected;
      };

      var ast = preprocess('<div></div>', {
        plugins: {
          ast: [ Plugin ]
        }
      });

      equal(ast, expected, 'return value from AST transform is used');
    });

    test('AST plugins can be chained', function() {
      expect(2);

      var expected = "OOOPS, MESSED THAT UP!";

      function Plugin() { }
      Plugin.prototype.transform = function() {
        return expected;
      };

      function SecondaryPlugin() { }
      SecondaryPlugin.prototype.transform = function(ast) {
        equal(ast, expected, 'return value from AST transform is used');

        return 'BOOM!';
      };

      var ast = preprocess('<div></div>', {
        plugins: {
          ast: [ 
            Plugin,
            SecondaryPlugin
          ]
        }
      });

      equal(ast, 'BOOM!', 'return value from last AST transform is used');
    });
  });
define("htmlbars-syntax-tests/plugin-node-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests');
    test('htmlbars-syntax-tests/plugin-node-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/plugin-node-test.js should pass jshint.'); 
    });
  });
define("htmlbars-syntax-tests/walker-node-test",
  ["../htmlbars-syntax/parser","../htmlbars-syntax/walker"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var preprocess = __dependency1__.preprocess;
    var Walker = __dependency2__["default"];

    function compareWalkedNodes(html, expected) {
      var ast = preprocess(html);
      var walker = new Walker();
      var nodes = [];

      walker.visit(ast, function(node) {
        nodes.push(node.type);
      });

      deepEqual(nodes, expected);
    }

    QUnit.module('AST Walker');

    test('walks elements', function() {
      compareWalkedNodes('<div><li></li></div>', [
        'Program',
        'ElementNode',
        'ElementNode'
      ]);
    });

    test('walks blocks', function() {
      compareWalkedNodes('{{#foo}}<li></li>{{/foo}}', [
        'Program',
        'BlockStatement',
        'Program',
        'ElementNode'
      ]);
    });

    test('walks components', function() {
      compareWalkedNodes('<my-foo><li></li></my-foo>', [
        'Program',
        'ComponentNode',
        'Program',
        'ElementNode'
      ]);
    });
  });
define("htmlbars-syntax-tests/walker-node-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-syntax-tests');
    test('htmlbars-syntax-tests/walker-node-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-syntax-tests/walker-node-test.js should pass jshint.'); 
    });
  });