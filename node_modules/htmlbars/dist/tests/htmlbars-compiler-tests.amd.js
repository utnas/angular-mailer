define("dom-helper",
  ["./morph-range","./morph-attr","./dom-helper/build-html-dom","./dom-helper/classes","./dom-helper/prop","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var Morph = __dependency1__["default"];
    var AttrMorph = __dependency2__["default"];
    var buildHTMLDOM = __dependency3__.buildHTMLDOM;
    var svgNamespace = __dependency3__.svgNamespace;
    var svgHTMLIntegrationPoints = __dependency3__.svgHTMLIntegrationPoints;
    var addClasses = __dependency4__.addClasses;
    var removeClasses = __dependency4__.removeClasses;
    var normalizeProperty = __dependency5__.normalizeProperty;
    var isAttrRemovalValue = __dependency5__.isAttrRemovalValue;

    var doc = typeof document === 'undefined' ? false : document;

    var deletesBlankTextNodes = doc && (function(document){
      var element = document.createElement('div');
      element.appendChild( document.createTextNode('') );
      var clonedElement = element.cloneNode(true);
      return clonedElement.childNodes.length === 0;
    })(doc);

    var ignoresCheckedAttribute = doc && (function(document){
      var element = document.createElement('input');
      element.setAttribute('checked', 'checked');
      var clonedElement = element.cloneNode(false);
      return !clonedElement.checked;
    })(doc);

    var canRemoveSvgViewBoxAttribute = doc && (doc.createElementNS ? (function(document){
      var element = document.createElementNS(svgNamespace, 'svg');
      element.setAttribute('viewBox', '0 0 100 100');
      element.removeAttribute('viewBox');
      return !element.getAttribute('viewBox');
    })(doc) : true);

    var canClone = doc && (function(document){
      var element = document.createElement('div');
      element.appendChild( document.createTextNode(' '));
      element.appendChild( document.createTextNode(' '));
      var clonedElement = element.cloneNode(true);
      return clonedElement.childNodes[0].nodeValue === ' ';
    })(doc);

    // This is not the namespace of the element, but of
    // the elements inside that elements.
    function interiorNamespace(element){
      if (
        element &&
        element.namespaceURI === svgNamespace &&
        !svgHTMLIntegrationPoints[element.tagName]
      ) {
        return svgNamespace;
      } else {
        return null;
      }
    }

    // The HTML spec allows for "omitted start tags". These tags are optional
    // when their intended child is the first thing in the parent tag. For
    // example, this is a tbody start tag:
    //
    // <table>
    //   <tbody>
    //     <tr>
    //
    // The tbody may be omitted, and the browser will accept and render:
    //
    // <table>
    //   <tr>
    //
    // However, the omitted start tag will still be added to the DOM. Here
    // we test the string and context to see if the browser is about to
    // perform this cleanup.
    //
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#optional-tags
    // describes which tags are omittable. The spec for tbody and colgroup
    // explains this behavior:
    //
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-tbody-element
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-colgroup-element
    //

    var omittedStartTagChildTest = /<([\w:]+)/;
    function detectOmittedStartTag(string, contextualElement){
      // Omitted start tags are only inside table tags.
      if (contextualElement.tagName === 'TABLE') {
        var omittedStartTagChildMatch = omittedStartTagChildTest.exec(string);
        if (omittedStartTagChildMatch) {
          var omittedStartTagChild = omittedStartTagChildMatch[1];
          // It is already asserted that the contextual element is a table
          // and not the proper start tag. Just see if a tag was omitted.
          return omittedStartTagChild === 'tr' ||
                 omittedStartTagChild === 'col';
        }
      }
    }

    function buildSVGDOM(html, dom){
      var div = dom.document.createElement('div');
      div.innerHTML = '<svg>'+html+'</svg>';
      return div.firstChild.childNodes;
    }

    /*
     * A class wrapping DOM functions to address environment compatibility,
     * namespaces, contextual elements for morph un-escaped content
     * insertion.
     *
     * When entering a template, a DOMHelper should be passed:
     *
     *   template(context, { hooks: hooks, dom: new DOMHelper() });
     *
     * TODO: support foreignObject as a passed contextual element. It has
     * a namespace (svg) that does not match its internal namespace
     * (xhtml).
     *
     * @class DOMHelper
     * @constructor
     * @param {HTMLDocument} _document The document DOM methods are proxied to
     */
    function DOMHelper(_document){
      this.document = _document || document;
      if (!this.document) {
        throw new Error("A document object must be passed to the DOMHelper, or available on the global scope");
      }
      this.canClone = canClone;
      this.namespace = null;
    }

    var prototype = DOMHelper.prototype;
    prototype.constructor = DOMHelper;

    prototype.getElementById = function(id, rootNode) {
      rootNode = rootNode || this.document;
      return rootNode.getElementById(id);
    };

    prototype.insertBefore = function(element, childElement, referenceChild) {
      return element.insertBefore(childElement, referenceChild);
    };

    prototype.appendChild = function(element, childElement) {
      return element.appendChild(childElement);
    };

    prototype.childAt = function(element, indices) {
      var child = element;

      for (var i = 0; i < indices.length; i++) {
        child = child.childNodes.item(indices[i]);
      }

      return child;
    };

    // Note to a Fellow Implementor:
    // Ahh, accessing a child node at an index. Seems like it should be so simple,
    // doesn't it? Unfortunately, this particular method has caused us a surprising
    // amount of pain. As you'll note below, this method has been modified to walk
    // the linked list of child nodes rather than access the child by index
    // directly, even though there are two (2) APIs in the DOM that do this for us.
    // If you're thinking to yourself, "What an oversight! What an opportunity to
    // optimize this code!" then to you I say: stop! For I have a tale to tell.
    //
    // First, this code must be compatible with simple-dom for rendering on the
    // server where there is no real DOM. Previously, we accessed a child node
    // directly via `element.childNodes[index]`. While we *could* in theory do a
    // full-fidelity simulation of a live `childNodes` array, this is slow,
    // complicated and error-prone.
    //
    // "No problem," we thought, "we'll just use the similar
    // `childNodes.item(index)` API." Then, we could just implement our own `item`
    // method in simple-dom and walk the child node linked list there, allowing
    // us to retain the performance advantages of the (surely optimized) `item()`
    // API in the browser.
    //
    // Unfortunately, an enterprising soul named Samy Alzahrani discovered that in
    // IE8, accessing an item out-of-bounds via `item()` causes an exception where
    // other browsers return null. This necessitated a... check of
    // `childNodes.length`, bringing us back around to having to support a
    // full-fidelity `childNodes` array!
    //
    // Worst of all, Kris Selden investigated how browsers are actualy implemented
    // and discovered that they're all linked lists under the hood anyway. Accessing
    // `childNodes` requires them to allocate a new live collection backed by that
    // linked list, which is itself a rather expensive operation. Our assumed
    // optimization had backfired! That is the danger of magical thinking about
    // the performance of native implementations.
    //
    // And this, my friends, is why the following implementation just walks the
    // linked list, as surprised as that may make you. Please ensure you understand
    // the above before changing this and submitting a PR.
    //
    // Tom Dale, January 18th, 2015, Portland OR
    prototype.childAtIndex = function(element, index) {
      var node = element.firstChild;

      for (var idx = 0; node && idx < index; idx++) {
        node = node.nextSibling;
      }

      return node;
    };

    prototype.appendText = function(element, text) {
      return element.appendChild(this.document.createTextNode(text));
    };

    prototype.setAttribute = function(element, name, value) {
      element.setAttribute(name, String(value));
    };

    prototype.setAttributeNS = function(element, namespace, name, value) {
      element.setAttributeNS(namespace, name, String(value));
    };

    if (canRemoveSvgViewBoxAttribute){
      prototype.removeAttribute = function(element, name) {
        element.removeAttribute(name);
      };
    } else {
      prototype.removeAttribute = function(element, name) {
        if (element.tagName === 'svg' && name === 'viewBox') {
          element.setAttribute(name, null);
        } else {
          element.removeAttribute(name);
        }
      };
    }

    prototype.setPropertyStrict = function(element, name, value) {
      element[name] = value;
    };

    prototype.setProperty = function(element, name, value, namespace) {
      var lowercaseName = name.toLowerCase();
      if (element.namespaceURI === svgNamespace || lowercaseName === 'style') {
        if (isAttrRemovalValue(value)) {
          element.removeAttribute(name);
        } else {
          if (namespace) {
            element.setAttributeNS(namespace, name, value);
          } else {
            element.setAttribute(name, value);
          }
        }
      } else {
        var normalized = normalizeProperty(element, name);
        if (normalized) {
          element[normalized] = value;
        } else {
          if (isAttrRemovalValue(value)) {
            element.removeAttribute(name);
          } else {
            if (namespace && element.setAttributeNS) {
              element.setAttributeNS(namespace, name, value);
            } else {
              element.setAttribute(name, value);
            }
          }
        }
      }
    };

    if (doc && doc.createElementNS) {
      // Only opt into namespace detection if a contextualElement
      // is passed.
      prototype.createElement = function(tagName, contextualElement) {
        var namespace = this.namespace;
        if (contextualElement) {
          if (tagName === 'svg') {
            namespace = svgNamespace;
          } else {
            namespace = interiorNamespace(contextualElement);
          }
        }
        if (namespace) {
          return this.document.createElementNS(namespace, tagName);
        } else {
          return this.document.createElement(tagName);
        }
      };
      prototype.setAttributeNS = function(element, namespace, name, value) {
        element.setAttributeNS(namespace, name, String(value));
      };
    } else {
      prototype.createElement = function(tagName) {
        return this.document.createElement(tagName);
      };
      prototype.setAttributeNS = function(element, namespace, name, value) {
        element.setAttribute(name, String(value));
      };
    }

    prototype.addClasses = addClasses;
    prototype.removeClasses = removeClasses;

    prototype.setNamespace = function(ns) {
      this.namespace = ns;
    };

    prototype.detectNamespace = function(element) {
      this.namespace = interiorNamespace(element);
    };

    prototype.createDocumentFragment = function(){
      return this.document.createDocumentFragment();
    };

    prototype.createTextNode = function(text){
      return this.document.createTextNode(text);
    };

    prototype.createComment = function(text){
      return this.document.createComment(text);
    };

    prototype.repairClonedNode = function(element, blankChildTextNodes, isChecked){
      if (deletesBlankTextNodes && blankChildTextNodes.length > 0) {
        for (var i=0, len=blankChildTextNodes.length;i<len;i++){
          var textNode = this.document.createTextNode(''),
              offset = blankChildTextNodes[i],
              before = this.childAtIndex(element, offset);
          if (before) {
            element.insertBefore(textNode, before);
          } else {
            element.appendChild(textNode);
          }
        }
      }
      if (ignoresCheckedAttribute && isChecked) {
        element.setAttribute('checked', 'checked');
      }
    };

    prototype.cloneNode = function(element, deep){
      var clone = element.cloneNode(!!deep);
      return clone;
    };

    prototype.createAttrMorph = function(element, attrName, namespace){
      return new AttrMorph(element, attrName, this, namespace);
    };

    prototype.createUnsafeAttrMorph = function(element, attrName, namespace){
      var morph = this.createAttrMorph(element, attrName, namespace);
      morph.escaped = false;
      return morph;
    };

    prototype.createMorph = function(parent, start, end, contextualElement){
      if (contextualElement && contextualElement.nodeType === 11) {
        throw new Error("Cannot pass a fragment as the contextual element to createMorph");
      }

      if (!contextualElement && parent.nodeType === 1) {
        contextualElement = parent;
      }
      var morph = new Morph(this, contextualElement);
      morph.firstNode = start;
      morph.lastNode = end;
      morph.state = {};
      morph.isDirty = true;
      return morph;
    };

    prototype.createUnsafeMorph = function(parent, start, end, contextualElement){
      var morph = this.createMorph(parent, start, end, contextualElement);
      morph.parseTextAsHTML = true;
      return morph;
    };

    // This helper is just to keep the templates good looking,
    // passing integers instead of element references.
    prototype.createMorphAt = function(parent, startIndex, endIndex, contextualElement){
      var single = startIndex === endIndex;
      var start = this.childAtIndex(parent, startIndex);
      var end = single ? start : this.childAtIndex(parent, endIndex);
      return this.createMorph(parent, start, end, contextualElement);
    };

    prototype.createUnsafeMorphAt = function(parent, startIndex, endIndex, contextualElement) {
      var morph = this.createMorphAt(parent, startIndex, endIndex, contextualElement);
      morph.parseTextAsHTML = true;
      return morph;
    };

    prototype.insertMorphBefore = function(element, referenceChild, contextualElement) {
      var insertion = this.document.createComment('');
      element.insertBefore(insertion, referenceChild);
      return this.createMorph(element, insertion, insertion, contextualElement);
    };

    prototype.appendMorph = function(element, contextualElement) {
      var insertion = this.document.createComment('');
      element.appendChild(insertion);
      return this.createMorph(element, insertion, insertion, contextualElement);
    };

    prototype.insertBoundary = function(fragment, index) {
      // this will always be null or firstChild
      var child = index === null ? null : this.childAtIndex(fragment, index);
      this.insertBefore(fragment, this.createTextNode(''), child);
    };

    prototype.parseHTML = function(html, contextualElement) {
      var childNodes;

      if (interiorNamespace(contextualElement) === svgNamespace) {
        childNodes = buildSVGDOM(html, this);
      } else {
        var nodes = buildHTMLDOM(html, contextualElement, this);
        if (detectOmittedStartTag(html, contextualElement)) {
          var node = nodes[0];
          while (node && node.nodeType !== 1) {
            node = node.nextSibling;
          }
          childNodes = node.childNodes;
        } else {
          childNodes = nodes;
        }
      }

      // Copy node list to a fragment.
      var fragment = this.document.createDocumentFragment();

      if (childNodes && childNodes.length > 0) {
        var currentNode = childNodes[0];

        // We prepend an <option> to <select> boxes to absorb any browser bugs
        // related to auto-select behavior. Skip past it.
        if (contextualElement.tagName === 'SELECT') {
          currentNode = currentNode.nextSibling;
        }

        while (currentNode) {
          var tempNode = currentNode;
          currentNode = currentNode.nextSibling;

          fragment.appendChild(tempNode);
        }
      }

      return fragment;
    };

    var parsingNode;

    // Used to determine whether a URL needs to be sanitized.
    prototype.protocolForURL = function(url) {
      if (!parsingNode) {
        parsingNode = this.document.createElement('a');
      }

      parsingNode.href = url;
      return parsingNode.protocol;
    };

    __exports__["default"] = DOMHelper;
  });
define("dom-helper.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('dom-helper.js should pass jshint', function() { 
      ok(true, 'dom-helper.js should pass jshint.'); 
    });
  });
define("dom-helper/build-html-dom",
  ["exports"],
  function(__exports__) {
    "use strict";
    /* global XMLSerializer:false */
    var svgHTMLIntegrationPoints = {foreignObject: 1, desc: 1, title: 1};
    __exports__.svgHTMLIntegrationPoints = svgHTMLIntegrationPoints;var svgNamespace = 'http://www.w3.org/2000/svg';
    __exports__.svgNamespace = svgNamespace;
    var doc = typeof document === 'undefined' ? false : document;

    // Safari does not like using innerHTML on SVG HTML integration
    // points (desc/title/foreignObject).
    var needsIntegrationPointFix = doc && (function(document) {
      if (document.createElementNS === undefined) {
        return;
      }
      // In FF title will not accept innerHTML.
      var testEl = document.createElementNS(svgNamespace, 'title');
      testEl.innerHTML = "<div></div>";
      return testEl.childNodes.length === 0 || testEl.childNodes[0].nodeType !== 1;
    })(doc);

    // Internet Explorer prior to 9 does not allow setting innerHTML if the first element
    // is a "zero-scope" element. This problem can be worked around by making
    // the first node an invisible text node. We, like Modernizr, use &shy;
    var needsShy = doc && (function(document) {
      var testEl = document.createElement('div');
      testEl.innerHTML = "<div></div>";
      testEl.firstChild.innerHTML = "<script><\/script>";
      return testEl.firstChild.innerHTML === '';
    })(doc);

    // IE 8 (and likely earlier) likes to move whitespace preceeding
    // a script tag to appear after it. This means that we can
    // accidentally remove whitespace when updating a morph.
    var movesWhitespace = doc && (function(document) {
      var testEl = document.createElement('div');
      testEl.innerHTML = "Test: <script type='text/x-placeholder'><\/script>Value";
      return testEl.childNodes[0].nodeValue === 'Test:' &&
              testEl.childNodes[2].nodeValue === ' Value';
    })(doc);

    var tagNamesRequiringInnerHTMLFix = doc && (function(document) {
      var tagNamesRequiringInnerHTMLFix;
      // IE 9 and earlier don't allow us to set innerHTML on col, colgroup, frameset,
      // html, style, table, tbody, tfoot, thead, title, tr. Detect this and add
      // them to an initial list of corrected tags.
      //
      // Here we are only dealing with the ones which can have child nodes.
      //
      var tableNeedsInnerHTMLFix;
      var tableInnerHTMLTestElement = document.createElement('table');
      try {
        tableInnerHTMLTestElement.innerHTML = '<tbody></tbody>';
      } catch (e) {
      } finally {
        tableNeedsInnerHTMLFix = (tableInnerHTMLTestElement.childNodes.length === 0);
      }
      if (tableNeedsInnerHTMLFix) {
        tagNamesRequiringInnerHTMLFix = {
          colgroup: ['table'],
          table: [],
          tbody: ['table'],
          tfoot: ['table'],
          thead: ['table'],
          tr: ['table', 'tbody']
        };
      }

      // IE 8 doesn't allow setting innerHTML on a select tag. Detect this and
      // add it to the list of corrected tags.
      //
      var selectInnerHTMLTestElement = document.createElement('select');
      selectInnerHTMLTestElement.innerHTML = '<option></option>';
      if (!selectInnerHTMLTestElement.childNodes[0]) {
        tagNamesRequiringInnerHTMLFix = tagNamesRequiringInnerHTMLFix || {};
        tagNamesRequiringInnerHTMLFix.select = [];
      }
      return tagNamesRequiringInnerHTMLFix;
    })(doc);

    function scriptSafeInnerHTML(element, html) {
      // without a leading text node, IE will drop a leading script tag.
      html = '&shy;'+html;

      element.innerHTML = html;

      var nodes = element.childNodes;

      // Look for &shy; to remove it.
      var shyElement = nodes[0];
      while (shyElement.nodeType === 1 && !shyElement.nodeName) {
        shyElement = shyElement.firstChild;
      }
      // At this point it's the actual unicode character.
      if (shyElement.nodeType === 3 && shyElement.nodeValue.charAt(0) === "\u00AD") {
        var newValue = shyElement.nodeValue.slice(1);
        if (newValue.length) {
          shyElement.nodeValue = shyElement.nodeValue.slice(1);
        } else {
          shyElement.parentNode.removeChild(shyElement);
        }
      }

      return nodes;
    }

    function buildDOMWithFix(html, contextualElement){
      var tagName = contextualElement.tagName;

      // Firefox versions < 11 do not have support for element.outerHTML.
      var outerHTML = contextualElement.outerHTML || new XMLSerializer().serializeToString(contextualElement);
      if (!outerHTML) {
        throw "Can't set innerHTML on "+tagName+" in this browser";
      }

      html = fixSelect(html, contextualElement);

      var wrappingTags = tagNamesRequiringInnerHTMLFix[tagName.toLowerCase()];

      var startTag = outerHTML.match(new RegExp("<"+tagName+"([^>]*)>", 'i'))[0];
      var endTag = '</'+tagName+'>';

      var wrappedHTML = [startTag, html, endTag];

      var i = wrappingTags.length;
      var wrappedDepth = 1 + i;
      while(i--) {
        wrappedHTML.unshift('<'+wrappingTags[i]+'>');
        wrappedHTML.push('</'+wrappingTags[i]+'>');
      }

      var wrapper = document.createElement('div');
      scriptSafeInnerHTML(wrapper, wrappedHTML.join(''));
      var element = wrapper;
      while (wrappedDepth--) {
        element = element.firstChild;
        while (element && element.nodeType !== 1) {
          element = element.nextSibling;
        }
      }
      while (element && element.tagName !== tagName) {
        element = element.nextSibling;
      }
      return element ? element.childNodes : [];
    }

    var buildDOM;
    if (needsShy) {
      buildDOM = function buildDOM(html, contextualElement, dom){
        html = fixSelect(html, contextualElement);

        contextualElement = dom.cloneNode(contextualElement, false);
        scriptSafeInnerHTML(contextualElement, html);
        return contextualElement.childNodes;
      };
    } else {
      buildDOM = function buildDOM(html, contextualElement, dom){
        html = fixSelect(html, contextualElement);

        contextualElement = dom.cloneNode(contextualElement, false);
        contextualElement.innerHTML = html;
        return contextualElement.childNodes;
      };
    }

    function fixSelect(html, contextualElement) {
      if (contextualElement.tagName === 'SELECT') {
        html = "<option></option>" + html;
      }

      return html;
    }

    var buildIESafeDOM;
    if (tagNamesRequiringInnerHTMLFix || movesWhitespace) {
      buildIESafeDOM = function buildIESafeDOM(html, contextualElement, dom) {
        // Make a list of the leading text on script nodes. Include
        // script tags without any whitespace for easier processing later.
        var spacesBefore = [];
        var spacesAfter = [];
        if (typeof html === 'string') {
          html = html.replace(/(\s*)(<script)/g, function(match, spaces, tag) {
            spacesBefore.push(spaces);
            return tag;
          });

          html = html.replace(/(<\/script>)(\s*)/g, function(match, tag, spaces) {
            spacesAfter.push(spaces);
            return tag;
          });
        }

        // Fetch nodes
        var nodes;
        if (tagNamesRequiringInnerHTMLFix[contextualElement.tagName.toLowerCase()]) {
          // buildDOMWithFix uses string wrappers for problematic innerHTML.
          nodes = buildDOMWithFix(html, contextualElement);
        } else {
          nodes = buildDOM(html, contextualElement, dom);
        }

        // Build a list of script tags, the nodes themselves will be
        // mutated as we add test nodes.
        var i, j, node, nodeScriptNodes;
        var scriptNodes = [];
        for (i=0;i<nodes.length;i++) {
          node=nodes[i];
          if (node.nodeType !== 1) {
            continue;
          }
          if (node.tagName === 'SCRIPT') {
            scriptNodes.push(node);
          } else {
            nodeScriptNodes = node.getElementsByTagName('script');
            for (j=0;j<nodeScriptNodes.length;j++) {
              scriptNodes.push(nodeScriptNodes[j]);
            }
          }
        }

        // Walk the script tags and put back their leading text nodes.
        var scriptNode, textNode, spaceBefore, spaceAfter;
        for (i=0;i<scriptNodes.length;i++) {
          scriptNode = scriptNodes[i];
          spaceBefore = spacesBefore[i];
          if (spaceBefore && spaceBefore.length > 0) {
            textNode = dom.document.createTextNode(spaceBefore);
            scriptNode.parentNode.insertBefore(textNode, scriptNode);
          }

          spaceAfter = spacesAfter[i];
          if (spaceAfter && spaceAfter.length > 0) {
            textNode = dom.document.createTextNode(spaceAfter);
            scriptNode.parentNode.insertBefore(textNode, scriptNode.nextSibling);
          }
        }

        return nodes;
      };
    } else {
      buildIESafeDOM = buildDOM;
    }

    var buildHTMLDOM;
    if (needsIntegrationPointFix) {
      buildHTMLDOM = function buildHTMLDOM(html, contextualElement, dom){
        if (svgHTMLIntegrationPoints[contextualElement.tagName]) {
          return buildIESafeDOM(html, document.createElement('div'), dom);
        } else {
          return buildIESafeDOM(html, contextualElement, dom);
        }
      };
    } else {
      buildHTMLDOM = buildIESafeDOM;
    }

    __exports__.buildHTMLDOM = buildHTMLDOM;
  });
define("dom-helper/build-html-dom.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - dom-helper');
    test('dom-helper/build-html-dom.js should pass jshint', function() { 
      ok(true, 'dom-helper/build-html-dom.js should pass jshint.'); 
    });
  });
define("dom-helper/classes",
  ["exports"],
  function(__exports__) {
    "use strict";
    var doc = typeof document === 'undefined' ? false : document;

    // PhantomJS has a broken classList. See https://github.com/ariya/phantomjs/issues/12782
    var canClassList = doc && (function(){
      var d = document.createElement('div');
      if (!d.classList) {
        return false;
      }
      d.classList.add('boo');
      d.classList.add('boo', 'baz');
      return (d.className === 'boo baz');
    })();

    function buildClassList(element) {
      var classString = (element.getAttribute('class') || '');
      return classString !== '' && classString !== ' ' ? classString.split(' ') : [];
    }

    function intersect(containingArray, valuesArray) {
      var containingIndex = 0;
      var containingLength = containingArray.length;
      var valuesIndex = 0;
      var valuesLength = valuesArray.length;

      var intersection = new Array(valuesLength);

      // TODO: rewrite this loop in an optimal manner
      for (;containingIndex<containingLength;containingIndex++) {
        valuesIndex = 0;
        for (;valuesIndex<valuesLength;valuesIndex++) {
          if (valuesArray[valuesIndex] === containingArray[containingIndex]) {
            intersection[valuesIndex] = containingIndex;
            break;
          }
        }
      }

      return intersection;
    }

    function addClassesViaAttribute(element, classNames) {
      var existingClasses = buildClassList(element);

      var indexes = intersect(existingClasses, classNames);
      var didChange = false;

      for (var i=0, l=classNames.length; i<l; i++) {
        if (indexes[i] === undefined) {
          didChange = true;
          existingClasses.push(classNames[i]);
        }
      }

      if (didChange) {
        element.setAttribute('class', existingClasses.length > 0 ? existingClasses.join(' ') : '');
      }
    }

    function removeClassesViaAttribute(element, classNames) {
      var existingClasses = buildClassList(element);

      var indexes = intersect(classNames, existingClasses);
      var didChange = false;
      var newClasses = [];

      for (var i=0, l=existingClasses.length; i<l; i++) {
        if (indexes[i] === undefined) {
          newClasses.push(existingClasses[i]);
        } else {
          didChange = true;
        }
      }

      if (didChange) {
        element.setAttribute('class', newClasses.length > 0 ? newClasses.join(' ') : '');
      }
    }

    var addClasses, removeClasses;
    if (canClassList) {
      addClasses = function addClasses(element, classNames) {
        if (element.classList) {
          if (classNames.length === 1) {
            element.classList.add(classNames[0]);
          } else if (classNames.length === 2) {
            element.classList.add(classNames[0], classNames[1]);
          } else {
            element.classList.add.apply(element.classList, classNames);
          }
        } else {
          addClassesViaAttribute(element, classNames);
        }
      };
      removeClasses = function removeClasses(element, classNames) {
        if (element.classList) {
          if (classNames.length === 1) {
            element.classList.remove(classNames[0]);
          } else if (classNames.length === 2) {
            element.classList.remove(classNames[0], classNames[1]);
          } else {
            element.classList.remove.apply(element.classList, classNames);
          }
        } else {
          removeClassesViaAttribute(element, classNames);
        }
      };
    } else {
      addClasses = addClassesViaAttribute;
      removeClasses = removeClassesViaAttribute;
    }

    __exports__.addClasses = addClasses;
    __exports__.removeClasses = removeClasses;
  });
define("dom-helper/classes.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - dom-helper');
    test('dom-helper/classes.js should pass jshint', function() { 
      ok(true, 'dom-helper/classes.js should pass jshint.'); 
    });
  });
define("dom-helper/prop",
  ["exports"],
  function(__exports__) {
    "use strict";
    function isAttrRemovalValue(value) {
      return value === null || value === undefined;
    }

    __exports__.isAttrRemovalValue = isAttrRemovalValue;// TODO should this be an o_create kind of thing?
    var propertyCaches = {};
    __exports__.propertyCaches = propertyCaches;
    function normalizeProperty(element, attrName) {
      var tagName = element.tagName;
      var key;
      var cache = propertyCaches[tagName];
      if (!cache) {
        // TODO should this be an o_create kind of thing?
        cache = {};
        for (key in element) {
          cache[key.toLowerCase()] = key;
        }
        propertyCaches[tagName] = cache;
      }

      // presumes that the attrName has been lowercased.
      return cache[attrName];
    }

    __exports__.normalizeProperty = normalizeProperty;
  });
define("dom-helper/prop.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - dom-helper');
    test('dom-helper/prop.js should pass jshint', function() { 
      ok(true, 'dom-helper/prop.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/fragment-test",
  ["../htmlbars-compiler/fragment-opcode-compiler","../htmlbars-compiler/fragment-javascript-compiler","../dom-helper","../htmlbars-syntax/parser","../htmlbars-test-helpers"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
    "use strict";
    var FragmentOpcodeCompiler = __dependency1__["default"];
    var FragmentJavaScriptCompiler = __dependency2__["default"];
    var DOMHelper = __dependency3__["default"];
    var preprocess = __dependency4__.preprocess;
    var equalHTML = __dependency5__.equalHTML;
    var getTextContent = __dependency5__.getTextContent;

    var xhtmlNamespace = "http://www.w3.org/1999/xhtml",
        svgNamespace = "http://www.w3.org/2000/svg";

    function fragmentFor(ast) {
      /* jshint evil: true */
      var fragmentOpcodeCompiler = new FragmentOpcodeCompiler(),
          fragmentCompiler = new FragmentJavaScriptCompiler();

      var opcodes = fragmentOpcodeCompiler.compile(ast);
      var program = fragmentCompiler.compile(opcodes);

      var fn = new Function("dom", 'return ' + program)();

      return fn(new DOMHelper());
    }

    QUnit.module('fragment');

    test('compiles a fragment', function () {
      var ast = preprocess("<div>{{foo}} bar {{baz}}</div>");
      var divNode = fragmentFor(ast).firstChild;

      equalHTML(divNode, "<div><!----> bar <!----></div>");
    });

    if (document && document.createElementNS) {
      test('compiles an svg fragment', function () {
        var ast = preprocess("<div><svg><circle/><foreignObject><span></span></foreignObject></svg></div>");
        var divNode = fragmentFor(ast).firstChild;

        equal( divNode.childNodes[0].namespaceURI, svgNamespace,
               'svg has the right namespace' );
        equal( divNode.childNodes[0].childNodes[0].namespaceURI, svgNamespace,
               'circle has the right namespace' );
        equal( divNode.childNodes[0].childNodes[1].namespaceURI, svgNamespace,
               'foreignObject has the right namespace' );
        equal( divNode.childNodes[0].childNodes[1].childNodes[0].namespaceURI, xhtmlNamespace,
               'span has the right namespace' );
      });
    }
      
    test('compiles an svg element with classes', function () {
      var ast = preprocess('<svg class="red right hand"></svg>');
      var svgNode = fragmentFor(ast).firstChild;

      equal(svgNode.getAttribute('class'), 'red right hand');
    });

    if (document && document.createElementNS) {
      test('compiles an svg element with proper namespace', function () {
        var ast = preprocess('<svg><use xlink:title="nice-title"></use></svg>');
        var svgNode = fragmentFor(ast).firstChild;

        equal(svgNode.childNodes[0].getAttributeNS('http://www.w3.org/1999/xlink', 'title'), 'nice-title');
        equal(svgNode.childNodes[0].attributes[0].namespaceURI, 'http://www.w3.org/1999/xlink');
        equal(svgNode.childNodes[0].attributes[0].name, 'xlink:title');
        equal(svgNode.childNodes[0].attributes[0].localName, 'title');
        equal(svgNode.childNodes[0].attributes[0].value, 'nice-title');
      });

    }
      
    test('converts entities to their char/string equivalent', function () {
      var ast = preprocess("<div title=\"&quot;Foo &amp; Bar&quot;\">lol &lt; &#60;&#x3c; &#x3C; &LT; &NotGreaterFullEqual; &Borksnorlax;</div>");
      var divNode = fragmentFor(ast).firstChild;

      equal(divNode.getAttribute('title'), '"Foo & Bar"');
      equal(getTextContent(divNode), "lol < << < < ≧̸ &Borksnorlax;");
    });
  });
define("htmlbars-compiler-tests/fragment-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/fragment-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/fragment-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/html-compiler-test",
  ["../htmlbars-compiler/compiler","../htmlbars-util/array-utils","../simple-html-tokenizer","../htmlbars-runtime/hooks","../htmlbars-runtime/helpers","../htmlbars-util/object-utils","../dom-helper","../htmlbars-test-helpers"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__) {
    "use strict";
    var compile = __dependency1__.compile;
    var forEach = __dependency2__.forEach;
    var tokenize = __dependency3__.tokenize;
    var defaultHooks = __dependency4__["default"];
    var defaultHelpers = __dependency5__["default"];
    var merge = __dependency6__.merge;
    var DOMHelper = __dependency7__["default"];
    var createObject = __dependency8__.createObject;
    var normalizeInnerHTML = __dependency8__.normalizeInnerHTML;
    var getTextContent = __dependency8__.getTextContent;

    var xhtmlNamespace = "http://www.w3.org/1999/xhtml",
        svgNamespace   = "http://www.w3.org/2000/svg";

    var hooks, helpers, partials, env;

    // IE8 doesn't correctly handle these html strings
    var innerHTMLSupportsCustomTags = (function() {
      var div = document.createElement('div');
      div.innerHTML = '<x-bar></x-bar>';
      return normalizeInnerHTML(div.innerHTML) === '<x-bar></x-bar>';
    })();

    // IE8 doesn't handle newlines in innerHTML correctly
    var innerHTMLHandlesNewlines = (function() {
      var div = document.createElement('div');
      div.innerHTML = 'foo\n\nbar';
      return div.innerHTML.length === 8;
    })();

    // IE8 removes comments and does other unspeakable things with innerHTML
    var ie8GenerateTokensNeeded = (function() {
      var div = document.createElement("div");
      div.innerHTML = "<!-- foobar -->";
      return div.innerHTML === "";
    })();

    function registerHelper(name, callback) {
      helpers[name] = callback;
    }

    function registerPartial(name, html) {
      partials[name] = compile(html);
    }

    function compilesTo(html, expected, context) {
      var template = compile(html);
      var fragment = template.render(context, env, document.body);
      equalTokens(fragment, expected === undefined ? html : expected);
      return fragment;
    }

    function generateTokens(fragmentOrHtml) {
      var div = document.createElement("div");
      if (typeof fragmentOrHtml === 'string') {
        div.innerHTML = fragmentOrHtml;
      } else {
        div.appendChild(fragmentOrHtml.cloneNode(true));
      }
      if (ie8GenerateTokensNeeded) {
        // IE8 drops comments and does other unspeakable things on `innerHTML`.
        // So in that case we do it to both the expected and actual so that they match.
        var div2 = document.createElement("div");
        div2.innerHTML = div.innerHTML;
        div.innerHTML = div2.innerHTML;
      }
      return tokenize(div.innerHTML);
    }

    function equalTokens(fragment, html) {
      var fragTokens = generateTokens(fragment);
      var htmlTokens = generateTokens(html);

      function normalizeTokens(token) {
        if (token.type === 'StartTag') {
          token.attributes = token.attributes.sort(function(a,b){
            if (a.name > b.name) {
              return 1;
            }
            if (a.name < b.name) {
              return -1;
            }
            return 0;
          });
        }
      }

      forEach(fragTokens, normalizeTokens);
      forEach(htmlTokens, normalizeTokens);

      deepEqual(fragTokens, htmlTokens);
    }

    function commonSetup() {
      hooks = merge({}, defaultHooks);
      helpers = merge({}, defaultHelpers);
      partials = {};

      env = {
        dom: new DOMHelper(),
        hooks: hooks,
        helpers: helpers,
        partials: partials,
        useFragmentCache: true
      };
    }

    QUnit.module("HTML-based compiler (output)", {
      beforeEach: commonSetup
    });

    test("Simple content produces a document fragment", function() {
      var template = compile("content");
      var fragment = template.render({}, env);

      equalTokens(fragment, "content");
    });

    test("Simple elements are created", function() {
      var template = compile("<h1>hello!</h1><div>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, "<h1>hello!</h1><div>content</div>");
    });

    test("Simple elements can have attributes", function() {
      var template = compile("<div class='foo' id='bar'>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, '<div class="foo" id="bar">content</div>');
    });

    test("Simple elements can have an empty attribute", function() {
      var template = compile("<div class=''>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, '<div class="">content</div>');
    });

    test("presence of `disabled` attribute without value marks as disabled", function() {
      var template = compile('<input disabled>');
      var inputNode = template.render({}, env).firstChild;

      ok(inputNode.disabled, 'disabled without value set as property is true');
    });

    test("Null quoted attribute value calls toString on the value", function() {
      var template = compile('<input disabled="{{isDisabled}}">');
      var inputNode = template.render({isDisabled: null}, env).firstChild;

      ok(inputNode.disabled, 'string of "null" set as property is true');
    });

    test("Null unquoted attribute value removes that attribute", function() {
      var template = compile('<input disabled={{isDisabled}}>');
      var inputNode = template.render({isDisabled: null}, env).firstChild;

      equalTokens(inputNode, '<input>');
    });

    test("unquoted attribute string is just that", function() {
      var template = compile('<input value=funstuff>');
      var inputNode = template.render({}, env).firstChild;

      equal(inputNode.tagName, 'INPUT', 'input tag');
      equal(inputNode.value, 'funstuff', 'value is set as property');
    });

    test("unquoted attribute expression is string", function() {
      var template = compile('<input value={{funstuff}}>');
      var inputNode = template.render({funstuff: "oh my"}, env).firstChild;

      equal(inputNode.tagName, 'INPUT', 'input tag');
      equal(inputNode.value, 'oh my', 'string is set to property');
    });

    test("unquoted attribute expression works when followed by another attribute", function() {
      var template = compile('<div foo={{funstuff}} name="Alice"></div>');
      var divNode = template.render({funstuff: "oh my"}, env).firstChild;

      equalTokens(divNode, '<div foo="oh my" name="Alice"></div>');
    });

    test("Unquoted attribute value with multiple nodes throws an exception", function () {
      expect(4);

      QUnit.throws(function() { compile('<img class=foo{{bar}}>'); }, expectedError(1));
      QUnit.throws(function() { compile('<img class={{foo}}{{bar}}>'); }, expectedError(1));
      QUnit.throws(function() { compile('<img \nclass={{foo}}bar>'); }, expectedError(2));
      QUnit.throws(function() { compile('<div \nclass\n=\n{{foo}}&amp;bar ></div>'); }, expectedError(4));

      function expectedError(line) {
        return new Error("Unquoted attribute value must be a single string or mustache (on line " + line + ")");
      }
    });

    test("Simple elements can have arbitrary attributes", function() {
      var template = compile("<div data-some-data='foo'>content</div>");
      var divNode = template.render({}, env).firstChild;
      equalTokens(divNode, '<div data-some-data="foo">content</div>');
    });

    test("checked attribute and checked property are present after clone and hydrate", function() {
      var template = compile("<input checked=\"checked\">");
      var inputNode = template.render({}, env).firstChild;
      equal(inputNode.tagName, 'INPUT', 'input tag');
      equal(inputNode.checked, true, 'input tag is checked');
    });


    function shouldBeVoid(tagName) {
      var html = "<" + tagName + " data-foo='bar'><p>hello</p>";
      var template = compile(html);
      var fragment = template.render({}, env);


      var div = document.createElement("div");
      div.appendChild(fragment.cloneNode(true));

      var tag = '<' + tagName + ' data-foo="bar">';
      var closing = '</' + tagName + '>';
      var extra = "<p>hello</p>";
      html = normalizeInnerHTML(div.innerHTML);

      QUnit.push((html === tag + extra) || (html === tag + closing + extra), html, tag + closing + extra, tagName + " should be a void element");
    }

    test("Void elements are self-closing", function() {
      var voidElements = "area base br col command embed hr img input keygen link meta param source track wbr";

      forEach(voidElements.split(" "), function(tagName) {
        shouldBeVoid(tagName);
      });
    });

    test("The compiler can handle nesting", function() {
      var html = '<div class="foo"><p><span id="bar" data-foo="bar">hi!</span></p></div>&nbsp;More content';
      var template = compile(html);
      var fragment = template.render({}, env);

      equalTokens(fragment, html);
    });

    test("The compiler can handle quotes", function() {
      compilesTo('<div>"This is a title," we\'re on a boat</div>');
    });

    test("The compiler can handle backslashes", function() {
      compilesTo('<div>This is a backslash: \\</div>');
    });

    if (innerHTMLHandlesNewlines) {

    test("The compiler can handle newlines", function() {
      compilesTo("<div>common\n\nbro</div>");
    });

    }

    test("The compiler can handle comments", function() {
      compilesTo("<div>{{! Better not break! }}content</div>", '<div>content</div>', {});
    });

    test("The compiler can handle HTML comments", function() {
      compilesTo('<div><!-- Just passing through --></div>');
    });

    test("The compiler can handle HTML comments with mustaches in them", function() {
      compilesTo('<div><!-- {{foo}} --></div>', '<div><!-- {{foo}} --></div>', { foo: 'bar' });
    });

    test("The compiler can handle HTML comments with complex mustaches in them", function() {
      compilesTo('<div><!-- {{foo bar baz}} --></div>', '<div><!-- {{foo bar baz}} --></div>', { foo: 'bar' });
    });

    test("The compiler can handle HTML comments with multi-line mustaches in them", function() {
      compilesTo('<div><!-- {{#each foo as |bar|}}\n{{bar}}\n\n{{/each}} --></div>');
    });

    test('The compiler can handle comments with no parent element', function() {
      compilesTo('<!-- {{foo}} -->');
    });

    // TODO: Revisit partial syntax.
    // test("The compiler can handle partials in handlebars partial syntax", function() {
    //   registerPartial('partial_name', "<b>Partial Works!</b>");
    //   compilesTo('<div>{{>partial_name}} Plaintext content</div>', '<div><b>Partial Works!</b> Plaintext content</div>', {});
    // });

    test("The compiler can handle partials in helper partial syntax", function() {
      registerPartial('partial_name', "<b>Partial Works!</b>");
      compilesTo('<div>{{partial "partial_name"}} Plaintext content</div>', '<div><b>Partial Works!</b> Plaintext content</div>', {});
    });

    test("The compiler can handle simple handlebars", function() {
      compilesTo('<div>{{title}}</div>', '<div>hello</div>', { title: 'hello' });
    });

    test("The compiler can handle escaping HTML", function() {
      compilesTo('<div>{{title}}</div>', '<div>&lt;strong&gt;hello&lt;/strong&gt;</div>', { title: '<strong>hello</strong>' });
    });

    test("The compiler can handle unescaped HTML", function() {
      compilesTo('<div>{{{title}}}</div>', '<div><strong>hello</strong></div>', { title: '<strong>hello</strong>' });
    });

    test("The compiler can handle top-level unescaped HTML", function() {
      compilesTo('{{{html}}}', '<strong>hello</strong>', { html: '<strong>hello</strong>' });
    });

    test("The compiler can handle top-level unescaped tr", function() {
      var template = compile('{{{html}}}');
      var context = { html: '<tr><td>Yo</td></tr>' };
      var fragment = template.render(context, env, document.createElement('table'));

      equal(
        fragment.firstChild.nextSibling.tagName, 'TR',
        "root tr is present" );
    });

    test("The compiler can handle top-level unescaped td inside tr contextualElement", function() {
      var template = compile('{{{html}}}');
      var context = { html: '<td>Yo</td>' };
      var fragment = template.render(context, env, document.createElement('tr'));

      equal(
        fragment.firstChild.nextSibling.tagName, 'TD',
        "root td is returned" );
    });

    test("The compiler can handle unescaped tr in top of content", function() {
      registerHelper('test', function(params, hash, options, env) {
        return options.template.render(this, env, options.morph.contextualElement);
      });

      var template = compile('{{#test}}{{{html}}}{{/test}}');
      var context = { html: '<tr><td>Yo</td></tr>' };
      var fragment = template.render(context, env, document.createElement('table'));

      equal(
        fragment.firstChild.nextSibling.nextSibling.tagName, 'TR',
        "root tr is present" );
    });

    test("The compiler can handle unescaped tr inside fragment table", function() {
      registerHelper('test', function(params, hash, options, env) {
        return options.template.render(this, env, options.morph.contextualElement);
      });

      var template = compile('<table>{{#test}}{{{html}}}{{/test}}</table>');
      var context = { html: '<tr><td>Yo</td></tr>' };
      var fragment = template.render(context, env, document.createElement('div'));
      var tableNode = fragment.firstChild;

      equal(
        tableNode.firstChild.nextSibling.tagName, 'TR',
        "root tr is present" );
    });

    test("The compiler can handle simple helpers", function() {
      registerHelper('testing', function(params) {
        return params[0];
      });

      compilesTo('<div>{{testing title}}</div>', '<div>hello</div>', { title: 'hello' });
    });

    test("The compiler can handle sexpr helpers", function() {
      registerHelper('testing', function(params) {
        return params[0] + "!";
      });

      compilesTo('<div>{{testing (testing "hello")}}</div>', '<div>hello!!</div>', {});
    });

    test("The compiler can handle multiple invocations of sexprs", function() {
      registerHelper('testing', function(params) {
        return "" + params[0] + params[1];
      });

      compilesTo('<div>{{testing (testing "hello" foo) (testing (testing bar "lol") baz)}}</div>', '<div>helloFOOBARlolBAZ</div>', { foo: "FOO", bar: "BAR", baz: "BAZ" });
    });

    test("The compiler passes along the hash arguments", function() {
      registerHelper('testing', function(params, hash) {
        return hash.first + '-' + hash.second;
      });

      compilesTo('<div>{{testing first="one" second="two"}}</div>', '<div>one-two</div>');
    });

    test("Simple data binding using text nodes", function() {
      var callback;

      hooks.content = function(env, morph, context, path) {
        callback = function() {
          morph.setContent(context[path]);
        };
        callback();
      };

      var object = { title: 'hello' };
      var fragment = compilesTo('<div>{{title}} world</div>', '<div>hello world</div>', object);

      object.title = 'goodbye';
      callback();

      equalTokens(fragment, '<div>goodbye world</div>');

      object.title = 'brown cow';
      callback();

      equalTokens(fragment, '<div>brown cow world</div>');
    });

    test("Simple data binding on fragments", function() {
      var callback;

      hooks.content = function(env, morph, context, path) {
        morph.parseTextAsHTML = true;
        callback = function() {
          morph.setContent(context[path]);
        };
        callback();
      };

      var object = { title: '<p>hello</p> to the' };
      var fragment = compilesTo('<div>{{title}} world</div>', '<div><p>hello</p> to the world</div>', object);

      object.title = '<p>goodbye</p> to the';
      callback();

      equalTokens(fragment, '<div><p>goodbye</p> to the world</div>');

      object.title = '<p>brown cow</p> to the';
      callback();

      equalTokens(fragment, '<div><p>brown cow</p> to the world</div>');
    });

    test("second render respects whitespace", function () {
      var template = compile('Hello {{ foo }} ');
      template.render({}, env, document.createElement('div'));
      var fragment = template.render({}, env, document.createElement('div'));
      equal(fragment.childNodes.length, 3, 'fragment contains 3 text nodes');
      equal(getTextContent(fragment.childNodes[0]), 'Hello ', 'first text node ends with one space character');
      equal(getTextContent(fragment.childNodes[2]), ' ', 'last text node contains one space character');
    });

    test("morph receives escaping information", function() {
      expect(3);

      hooks.content = function(env, morph, context, path) {
        if (path === 'escaped') {
          equal(morph.parseTextAsHTML, false);
        } else if (path === 'unescaped') {
          equal(morph.parseTextAsHTML, true);
        }

        morph.setContent(path);
      };

      // so we NEED a reference to div. because it's passed in twice.
      // not divs childNodes.
      // the parent we need to save is fragment.childNodes
      compilesTo('<div>{{escaped}}-{{{unescaped}}}</div>', '<div>escaped-unescaped</div>');
    });

    test("Morphs are escaped correctly", function() {
      expect(10);

      registerHelper('testing-unescaped', function(params, hash, options) {
        equal(options.morph.parseTextAsHTML, true);

        return params[0];
      });

      registerHelper('testing-escaped', function(params, hash, options, env) {
        equal(options.morph.parseTextAsHTML, false);

        if (options.template) {
          return options.template.render({}, env, options.morph.contextualElement);
        }

        return params[0];
      });

      compilesTo('<div>{{{testing-unescaped}}}-{{{testing-unescaped "a"}}}</div>', '<div><!---->-a</div>');
      compilesTo('<div>{{testing-escaped}}-{{testing-escaped "b"}}</div>', '<div><!---->-b</div>');
      compilesTo('<div>{{#testing-escaped}}c{{/testing-escaped}}</div>', '<div>c</div>');
      compilesTo('<div><testing-escaped>c</testing-escaped></div>', '<div>c</div>');
    });

    test("Attributes can use computed values", function() {
      compilesTo('<a href="{{url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });

    test("Mountain range of nesting", function() {
      var context = { foo: "FOO", bar: "BAR", baz: "BAZ", boo: "BOO", brew: "BREW", bat: "BAT", flute: "FLUTE", argh: "ARGH" };
      compilesTo('{{foo}}<span></span>', 'FOO<span></span>', context);
      compilesTo('<span></span>{{foo}}', '<span></span>FOO', context);
      compilesTo('<span>{{foo}}</span>{{foo}}', '<span>FOO</span>FOO', context);
      compilesTo('{{foo}}<span>{{foo}}</span>{{foo}}', 'FOO<span>FOO</span>FOO', context);
      compilesTo('{{foo}}<span></span>{{foo}}', 'FOO<span></span>FOO', context);
      compilesTo('{{foo}}<span></span>{{bar}}<span><span><span>{{baz}}</span></span></span>',
                 'FOO<span></span>BAR<span><span><span>BAZ</span></span></span>', context);
      compilesTo('{{foo}}<span></span>{{bar}}<span>{{argh}}<span><span>{{baz}}</span></span></span>',
                 'FOO<span></span>BAR<span>ARGH<span><span>BAZ</span></span></span>', context);
      compilesTo('{{foo}}<span>{{bar}}<a>{{baz}}<em>{{boo}}{{brew}}</em>{{bat}}</a></span><span><span>{{flute}}</span></span>{{argh}}',
                 'FOO<span>BAR<a>BAZ<em>BOOBREW</em>BAT</a></span><span><span>FLUTE</span></span>ARGH', context);
    });

    // test("Attributes can use computed paths", function() {
    //   compilesTo('<a href="{{post.url}}">linky</a>', '<a href="linky.html">linky</a>', { post: { url: 'linky.html' }});
    // });

    /*

    test("It is possible to use RESOLVE_IN_ATTR for data binding", function() {
      var callback;

      registerHelper('RESOLVE_IN_ATTR', function(parts, options) {
        return boundValue(function(c) {
          callback = c;
          return this[parts[0]];
        }, this);
      });

      var object = { url: 'linky.html' };
      var fragment = compilesTo('<a href="{{url}}">linky</a>', '<a href="linky.html">linky</a>', object);

      object.url = 'clippy.html';
      callback();

      equalTokens(fragment, '<a href="clippy.html">linky</a>');

      object.url = 'zippy.html';
      callback();

      equalTokens(fragment, '<a href="zippy.html">linky</a>');
    });
    */

    test("Attributes can be populated with helpers that generate a string", function() {
      registerHelper('testing', function(params) {
        return params[0];
      });

      compilesTo('<a href="{{testing url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html'});
    });
    /*
    test("A helper can return a stream for the attribute", function() {
      registerHelper('testing', function(path, options) {
        return streamValue(this[path]);
      });

      compilesTo('<a href="{{testing url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html'});
    });
    */
    test("Attribute helpers take a hash", function() {
      registerHelper('testing', function(params, hash) {
        return hash.path;
      });

      compilesTo('<a href="{{testing path=url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });
    /*
    test("Attribute helpers can use the hash for data binding", function() {
      var callback;

      registerHelper('testing', function(path, hash, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path] ? hash.truthy : hash.falsy;
        }, this);
      });

      var object = { on: true };
      var fragment = compilesTo('<div class="{{testing on truthy="yeah" falsy="nope"}}">hi</div>', '<div class="yeah">hi</div>', object);

      object.on = false;
      callback();
      equalTokens(fragment, '<div class="nope">hi</div>');
    });
    */
    test("Attributes containing multiple helpers are treated like a block", function() {
      registerHelper('testing', function(params) {
        return params[0];
      });

      compilesTo('<a href="http://{{foo}}/{{testing bar}}/{{testing "baz"}}">linky</a>', '<a href="http://foo.com/bar/baz">linky</a>', { foo: 'foo.com', bar: 'bar' });
    });

    test("Attributes containing a helper are treated like a block", function() {
      expect(2);

      registerHelper('testing', function(params) {
        deepEqual(params, [123]);
        return "example.com";
      });

      compilesTo('<a href="http://{{testing 123}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', { person: { url: 'example.com' } });
    });
    /*
    test("It is possible to trigger a re-render of an attribute from a child resolution", function() {
      var callback;

      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path];
        }, this);
      });

      var context = { url: "example.com" };
      var fragment = compilesTo('<a href="http://{{url}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', context);

      context.url = "www.example.com";
      callback();

      equalTokens(fragment, '<a href="http://www.example.com/index.html">linky</a>');
    });

    test("A child resolution can pass contextual information to the parent", function() {
      var callback;

      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path];
        }, this);
      });

      var context = { url: "example.com" };
      var fragment = compilesTo('<a href="http://{{url}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', context);

      context.url = "www.example.com";
      callback();

      equalTokens(fragment, '<a href="http://www.example.com/index.html">linky</a>');
    });

    test("Attribute runs can contain helpers", function() {
      var callbacks = [];

      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callbacks.push(c);
          return this[path];
        }, this);
      });

      registerHelper('testing', function(path, options) {
        return boundValue(function(c) {
          callbacks.push(c);

          if (options.paramTypes[0] === 'id') {
            return this[path] + '.html';
          } else {
            return path;
          }
        }, this);
      });

      var context = { url: "example.com", path: 'index' };
      var fragment = compilesTo('<a href="http://{{url}}/{{testing path}}/{{testing "linky"}}">linky</a>', '<a href="http://example.com/index.html/linky">linky</a>', context);

      context.url = "www.example.com";
      context.path = "yep";
      forEach(callbacks, function(callback) { callback(); });

      equalTokens(fragment, '<a href="http://www.example.com/yep.html/linky">linky</a>');

      context.url = "nope.example.com";
      context.path = "nope";
      forEach(callbacks, function(callback) { callback(); });

      equalTokens(fragment, '<a href="http://nope.example.com/nope.html/linky">linky</a>');
    });
    */
    test("A simple block helper can return the default document fragment", function() {
      registerHelper('testing', function(params, hash, options, env) {
        return options.template.render(this, env);
      });

      compilesTo('{{#testing}}<div id="test">123</div>{{/testing}}', '<div id="test">123</div>');
    });

    test("A simple block helper can return text", function() {
      registerHelper('testing', function(params, hash, options, env) {
        return options.template.render(this, env);
      });

      compilesTo('{{#testing}}test{{else}}not shown{{/testing}}', 'test');
    });

    test("A block helper can have an else block", function() {
      registerHelper('testing', function(params, hash, options, env) {
        return options.inverse.render(this, env);
      });

      compilesTo('{{#testing}}Nope{{else}}<div id="test">123</div>{{/testing}}', '<div id="test">123</div>');
    });

    test("A block helper can pass a context to be used in the child", function() {
      registerHelper('testing', function(params, hash, options, env) {
        var context = { title: 'Rails is omakase' };
        return options.template.render(context, env);
      });

      compilesTo('{{#testing}}<div id="test">{{title}}</div>{{/testing}}', '<div id="test">Rails is omakase</div>');
    });

    test("Block helpers receive hash arguments", function() {
      registerHelper('testing', function(params, hash, options, env) {
        if (hash.truth) {
          return options.template.render(this, env);
        }
      });

      compilesTo('{{#testing truth=true}}<p>Yep!</p>{{/testing}}{{#testing truth=false}}<p>Nope!</p>{{/testing}}', '<p>Yep!</p><!---->');
    });

    test("Node helpers can modify the node", function() {
      registerHelper('testing', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo('<div {{testing}}>Node helpers</div>', '<div zomg="zomg">Node helpers</div>');
    });

    test("Node helpers can modify the node after one node appended by top-level helper", function() {
      registerHelper('top-helper', function() {
        return document.createElement('span');
      });
      registerHelper('attr-helper', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo('<div {{attr-helper}}>Node helpers</div>{{top-helper}}', '<div zomg="zomg">Node helpers</div><span></span>');
    });

    test("Node helpers can modify the node after one node prepended by top-level helper", function() {
      registerHelper('top-helper', function() {
        return document.createElement('span');
      });
      registerHelper('attr-helper', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo('{{top-helper}}<div {{attr-helper}}>Node helpers</div>', '<span></span><div zomg="zomg">Node helpers</div>');
    });

    test("Node helpers can modify the node after many nodes returned from top-level helper", function() {
      registerHelper('top-helper', function() {
        var frag = document.createDocumentFragment();
        frag.appendChild(document.createElement('span'));
        frag.appendChild(document.createElement('span'));
        return frag;
      });
      registerHelper('attr-helper', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo(
        '{{top-helper}}<div {{attr-helper}}>Node helpers</div>',
        '<span></span><span></span><div zomg="zomg">Node helpers</div>' );
    });

    test("Node helpers can be used for attribute bindings", function() {
      var callback;

      registerHelper('testing', function(params, hash, options) {
        var path = hash.href,
            element = options.element;
        var context = this;

        callback = function() {
          var value = context[path];
          element.setAttribute('href', value);
        };

        callback();
      });

      var object = { url: 'linky.html' };
      var fragment = compilesTo('<a {{testing href="url"}}>linky</a>', '<a href="linky.html">linky</a>', object);

      object.url = 'zippy.html';
      callback();

      equalTokens(fragment, '<a href="zippy.html">linky</a>');
    });


    test('Components - Called as helpers', function () {
      registerHelper('x-append', function(params, hash, options, env) {
        var fragment = options.template.render(this, env, options.morph.contextualElement);
        fragment.appendChild(document.createTextNode(hash.text));
        return fragment;
      });
      var object = { bar: 'e', baz: 'c' };
      compilesTo('a<x-append text="d{{bar}}">b{{baz}}</x-append>f','abcdef', object);
    });

    if (innerHTMLSupportsCustomTags) {

    test('Components - Unknown helpers fall back to elements', function () {
      var object = { size: 'med', foo: 'b' };
      compilesTo('<x-bar class="btn-{{size}}">a{{foo}}c</x-bar>','<x-bar class="btn-med">abc</x-bar>', object);
    });

    test('Components - Text-only attributes work', function () {
      var object = { foo: 'qux' };
      compilesTo('<x-bar id="test">{{foo}}</x-bar>','<x-bar id="test">qux</x-bar>', object);
    });

    test('Components - Empty components work', function () {
      compilesTo('<x-bar></x-bar>','<x-bar></x-bar>', {});
    });

    test('Components - Text-only dashed attributes work', function () {
      var object = { foo: 'qux' };
      compilesTo('<x-bar aria-label="foo" id="test">{{foo}}</x-bar>','<x-bar aria-label="foo" id="test">qux</x-bar>', object);
    });

    }

    test('Repaired text nodes are ensured in the right place', function () {
      var object = { a: "A", b: "B", c: "C", d: "D" };
      compilesTo('{{a}} {{b}}', 'A B', object);
      compilesTo('<div>{{a}}{{b}}{{c}}wat{{d}}</div>', '<div>ABCwatD</div>', object);
      compilesTo('{{a}}{{b}}<img><img><img><img>', 'AB<img><img><img><img>', object);
    });

    test("Simple elements can have dashed attributes", function() {
      var template = compile("<div aria-label='foo'>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, '<div aria-label="foo">content</div>');
    });

    test("Block params", function() {
      registerHelper('a', function(params, hash, options, env) {
        var context = createObject(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['W', 'X1']));
        return 'A(' + span.innerHTML + ')';
      });
      registerHelper('b', function(params, hash, options, env) {
        var context = createObject(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['X2', 'Y']));
        return 'B(' + span.innerHTML + ')';
      });
      registerHelper('c', function(params, hash, options, env) {
        var context = createObject(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['Z']));
        return 'C(' + span.innerHTML + ')';
        // return "C(" + options.template.render() + ")";
      });
      var t = '{{#a as |w x|}}{{w}},{{x}} {{#b as |x y|}}{{x}},{{y}}{{/b}} {{w}},{{x}} {{#c as |z|}}{{x}},{{z}}{{/c}}{{/a}}';
      compilesTo(t, 'A(W,X1 B(X2,Y) W,X1 C(X1,Z))', {});
    });

    test("Block params - Helper should know how many block params it was called with", function() {
      expect(4);

      registerHelper('count-block-params', function(params, hash, options) {
        equal(options.template.blockParams, this.count, 'Helpers should receive the correct number of block params in options.template.blockParams.');
      });

      compile('{{#count-block-params}}{{/count-block-params}}').render({ count: 0 }, env, document.body);
      compile('{{#count-block-params as |x|}}{{/count-block-params}}').render({ count: 1 }, env, document.body);
      compile('{{#count-block-params as |x y|}}{{/count-block-params}}').render({ count: 2 }, env, document.body);
      compile('{{#count-block-params as |x y z|}}{{/count-block-params}}').render({ count: 3 }, env, document.body);
    });

    test('Block params in HTML syntax', function () {
      registerHelper('x-bar', function(params, hash, options, env) {
        var context = createObject(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['Xerxes', 'York', 'Zed']));
        return 'BAR(' + span.innerHTML + ')';
      });
      compilesTo('<x-bar as |x y zee|>{{zee}},{{y}},{{x}}</x-bar>', 'BAR(Zed,York,Xerxes)', {});
    });

    test('Block params in HTML syntax - Throws exception if given zero parameters', function () {
      expect(2);

      QUnit.throws(function() {
        compile('<x-bar as ||>foo</x-bar>');
      }, /Cannot use zero block parameters: 'as \|\|'/);
      QUnit.throws(function() {
        compile('<x-bar as | |>foo</x-bar>');
      }, /Cannot use zero block parameters: 'as \| \|'/);
    });


    test('Block params in HTML syntax - Works with a single parameter', function () {
      registerHelper('x-bar', function(params, hash, options, env) {
        return options.template.render({}, env, document.body, ['Xerxes']);
      });
      compilesTo('<x-bar as |x|>{{x}}</x-bar>', 'Xerxes', {});
    });

    test('Block params in HTML syntax - Works with other attributes', function () {
      registerHelper('x-bar', function(params, hash) {
        deepEqual(hash, {firstName: 'Alice', lastName: 'Smith'});
      });
      compile('<x-bar firstName="Alice" lastName="Smith" as |x y|></x-bar>').render({}, env, document.body);
    });

    test('Block params in HTML syntax - Ignores whitespace', function () {
      expect(3);

      registerHelper('x-bar', function(params, hash, options) {
        return options.template.render({}, env, document.body, ['Xerxes', 'York']);
      });
      compilesTo('<x-bar as |x y|>{{x}},{{y}}</x-bar>', 'Xerxes,York', {});
      compilesTo('<x-bar as | x y|>{{x}},{{y}}</x-bar>', 'Xerxes,York', {});
      compilesTo('<x-bar as | x y |>{{x}},{{y}}</x-bar>', 'Xerxes,York', {});
    });

    test('Block params in HTML syntax - Helper should know how many block params it was called with', function () {
      expect(4);

      registerHelper('count-block-params', function(params, hash, options) {
        equal(options.template.blockParams, this.count, 'Helpers should receive the correct number of block params in options.template.blockParams.');
      });

      compile('<count-block-params></count-block-params>').render({ count: 0 }, env, document.body);
      compile('<count-block-params as |x|></count-block-params>').render({ count: 1 }, env, document.body);
      compile('<count-block-params as |x y|></count-block-params>').render({ count: 2 }, env, document.body);
      compile('<count-block-params as |x y z|></count-block-params>').render({ count: 3 }, env, document.body);
    });

    test("Block params in HTML syntax - Throws an error on invalid block params syntax", function() {
      expect(3);

      QUnit.throws(function() {
        compile('<x-bar as |x y>{{x}},{{y}}</x-bar>');
      }, /Invalid block parameters syntax: 'as |x y'/);
      QUnit.throws(function() {
        compile('<x-bar as |x| y>{{x}},{{y}}</x-bar>');
      }, /Invalid block parameters syntax: 'as \|x\| y'/);
      QUnit.throws(function() {
        compile('<x-bar as |x| y|>{{x}},{{y}}</x-bar>');
      }, /Invalid block parameters syntax: 'as \|x\| y\|'/);
    });

    test("Block params in HTML syntax - Throws an error on invalid identifiers for params", function() {
      expect(3);

      QUnit.throws(function() {
        compile('<x-bar as |x foo.bar|></x-bar>');
      }, /Invalid identifier for block parameters: 'foo\.bar' in 'as \|x foo\.bar|'/);
      QUnit.throws(function() {
        compile('<x-bar as |x "foo"|></x-bar>');
      }, /Invalid identifier for block parameters: '"foo"' in 'as \|x "foo"|'/);
      QUnit.throws(function() {
        compile('<x-bar as |foo[bar]|></x-bar>');
      }, /Invalid identifier for block parameters: 'foo\[bar\]' in 'as \|foo\[bar\]\|'/);
    });

    QUnit.module("HTML-based compiler (invalid HTML errors)", {
      beforeEach: commonSetup
    });

    test("A helpful error message is provided for unclosed elements", function() {
      expect(2);

      QUnit.throws(function() {
        compile('\n<div class="my-div" \n foo={{bar}}>\n<span>\n</span>\n');
      }, /Unclosed element `div` \(on line 2\)\./);
      QUnit.throws(function() {
        compile('\n<div class="my-div">\n<span>\n');
      }, /Unclosed element `span` \(on line 3\)\./);
    });

    test("A helpful error message is provided for unmatched end tags", function() {
      expect(2);

      QUnit.throws(function() {
        compile("</p>");
      }, /Closing tag `p` \(on line 1\) without an open tag\./);
      QUnit.throws(function() {
        compile("<em>{{ foo }}</em> \n {{ bar }}\n</div>");
      }, /Closing tag `div` \(on line 3\) without an open tag\./);
    });

    test("A helpful error message is provided for end tags for void elements", function() {
      expect(2);

      QUnit.throws(function() {
        compile("<input></input>");
      }, /Invalid end tag `input` \(on line 1\) \(void elements cannot have end tags\)./);
      QUnit.throws(function() {
        compile("\n\n</br>");
      }, /Invalid end tag `br` \(on line 3\) \(void elements cannot have end tags\)./);
    });

    test("A helpful error message is provided for end tags with attributes", function() {
      QUnit.throws(function() {
        compile('<div>\nSomething\n\n</div foo="bar">');
      }, /Invalid end tag: closing tag must not have attributes, in `div` \(on line 4\)\./);
    });

    test("A helpful error message is provided for missing whitespace when self-closing a tag", function () {
      QUnit.throws(function() {
        compile('<div foo=bar/>');
      }, /A space is required between an unquoted attribute value and `\/`, in `div` \(on line 1\)\./);
      QUnit.throws(function() {
        compile('<span\n foo={{bar}}/>');
      }, /A space is required between an unquoted attribute value and `\/`, in `span` \(on line 2\)\./);
    });

    test("A helpful error message is provided for mismatched start/end tags", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\nSomething\n\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    // These skipped tests don't actually have anything to do with innerHTML,
    // but are related to IE8 doing Bad Things with newlines. This should
    // likely have its own feature detect instead of using this one.
    if (innerHTMLHandlesNewlines) {

    test("error line numbers include comment lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{! some comment}}\n\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include mustache only lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{someProp}}\n\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include block lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{#some-comment}}\n{{/some-comment}}\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include whitespace control mustaches", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{someProp~}}\n\n</div>{{some-comment}}");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include multiple mustache lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{some-comment}}</div>{{some-comment}}");
      }, /Closing tag `div` \(on line 3\) did not match last open tag `p` \(on line 2\)\./);
    });

    }

    if (document.createElement('div').namespaceURI) {

    QUnit.module("HTML-based compiler (output, svg)", {
      beforeEach: commonSetup
    });

    test("Simple elements can have namespaced attributes", function() {
      var template = compile("<svg xlink:title='svg-title'>content</svg>");
      var svgNode = template.render({}, env).firstChild;

      equalTokens(svgNode, '<svg xlink:title="svg-title">content</svg>');
      equal(svgNode.attributes[0].namespaceURI, 'http://www.w3.org/1999/xlink');
    });

    test("Simple elements can have bound namespaced attributes", function() {
      var template = compile("<svg xlink:title={{title}}>content</svg>");
      var svgNode = template.render({title: 'svg-title'}, env).firstChild;

      equalTokens(svgNode, '<svg xlink:title="svg-title">content</svg>');
      equal(svgNode.attributes[0].namespaceURI, 'http://www.w3.org/1999/xlink');
    });

    test("SVG element can have capitalized attributes", function() {
      var template = compile("<svg viewBox=\"0 0 0 0\"></svg>");
      var svgNode = template.render({}, env).firstChild;
      equalTokens(svgNode, '<svg viewBox=\"0 0 0 0\"></svg>');
    });

    test("The compiler can handle namespaced elements", function() {
      var html = '<svg><path stroke="black" d="M 0 0 L 100 100"></path></svg>';
      var template = compile(html);
      var svgNode = template.render({}, env).firstChild;

      equal(svgNode.namespaceURI, svgNamespace, "creates the svg element with a namespace");
      equalTokens(svgNode, html);
    });

    test("The compiler sets namespaces on nested namespaced elements", function() {
      var html = '<svg><path stroke="black" d="M 0 0 L 100 100"></path></svg>';
      var template = compile(html);
      var svgNode = template.render({}, env).firstChild;

      equal( svgNode.childNodes[0].namespaceURI, svgNamespace,
             "creates the path element with a namespace" );
      equalTokens(svgNode, html);
    });

    test("The compiler sets a namespace on an HTML integration point", function() {
      var html = '<svg><foreignObject>Hi</foreignObject></svg>';
      var template = compile(html);
      var svgNode = template.render({}, env).firstChild;

      equal( svgNode.namespaceURI, svgNamespace,
             "creates the svg element with a namespace" );
      equal( svgNode.childNodes[0].namespaceURI, svgNamespace,
             "creates the foreignObject element with a namespace" );
      equalTokens(svgNode, html);
    });

    test("The compiler does not set a namespace on an element inside an HTML integration point", function() {
      var html = '<svg><foreignObject><div></div></foreignObject></svg>';
      var template = compile(html);
      var svgNode = template.render({}, env).firstChild;

      equal( svgNode.childNodes[0].childNodes[0].namespaceURI, xhtmlNamespace,
             "creates the div inside the foreignObject without a namespace" );
      equalTokens(svgNode, html);
    });

    test("The compiler pops back to the correct namespace", function() {
      var html = '<svg></svg><svg></svg><div></div>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             "creates the first svg element with a namespace" );
      equal( fragment.childNodes[1].namespaceURI, svgNamespace,
             "creates the second svg element with a namespace" );
      equal( fragment.childNodes[2].namespaceURI, xhtmlNamespace,
             "creates the div element without a namespace" );
      equalTokens(fragment, html);
    });

    test("The compiler pops back to the correct namespace even if exiting last child", function () {
      var html = '<div><svg></svg></div><div></div>';
      var fragment = compile(html).render({}, env);

      equal(fragment.firstChild.namespaceURI, xhtmlNamespace, "first div's namespace is xhtmlNamespace");
      equal(fragment.firstChild.firstChild.namespaceURI, svgNamespace, "svg's namespace is svgNamespace");
      equal(fragment.lastChild.namespaceURI, xhtmlNamespace, "last div's namespace is xhtmlNamespace");
    });

    test("The compiler preserves capitalization of tags", function() {
      var html = '<svg><linearGradient id="gradient"></linearGradient></svg>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equalTokens(fragment, html);
    });

    test("svg can live with hydration", function() {
      var template = compile('<svg></svg>{{name}}');

      var fragment = template.render({ name: 'Milly' }, env, document.body);
      equal(
        fragment.childNodes[0].namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );
    });

    test("top-level unsafe morph uses the correct namespace", function() {
      var template = compile('<svg></svg>{{{foo}}}');
      var fragment = template.render({ foo: '<span>FOO</span>' }, env, document.body);

      equal(getTextContent(fragment), 'FOO', 'element from unsafe morph is displayed');
      equal(fragment.childNodes[1].namespaceURI, xhtmlNamespace, 'element from unsafe morph has correct namespace');
    });

    test("nested unsafe morph uses the correct namespace", function() {
      var template = compile('<svg>{{{foo}}}</svg><div></div>');
      var fragment = template.render({ foo: '<path></path>' }, env, document.body);

      equal(fragment.childNodes[0].childNodes[0].namespaceURI, svgNamespace,
            'element from unsafe morph has correct namespace');
    });

    test("svg can take some hydration", function() {
      var template = compile('<div><svg>{{name}}</svg></div>');

      var fragment = template.render({ name: 'Milly' }, env);
      equal(
        fragment.firstChild.childNodes[0].namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );
      equalTokens( fragment.firstChild, '<div><svg>Milly</svg></div>',
                 "html is valid" );
    });

    test("root svg can take some hydration", function() {
      var template = compile('<svg>{{name}}</svg>');
      var fragment = template.render({ name: 'Milly' }, env);
      var svgNode = fragment.firstChild;
      equal(
        svgNode.namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );
      equalTokens( svgNode, '<svg>Milly</svg>',
                 "html is valid" );
    });

    test("Block helper allows interior namespace", function() {
      var isTrue = true;

      registerHelper('testing', function(params, hash, options, env) {
        var morph = options.morph;
        if (isTrue) {
          return options.template.render(this, env, morph.contextualElement);
        } else {
          return options.inverse.render(this, env, morph.contextualElement);
        }
      });

      var template = compile('{{#testing}}<svg></svg>{{else}}<div><svg></svg></div>{{/testing}}');

      var fragment = template.render({ isTrue: true }, env, document.body);
      equal(
        fragment.firstChild.nextSibling.namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );

      isTrue = false;
      fragment = template.render({ isTrue: false }, env, document.body);
      equal(
        fragment.firstChild.nextSibling.namespaceURI, xhtmlNamespace,
        "inverse block path has a normal namespace");
      equal(
        fragment.firstChild.nextSibling.firstChild.namespaceURI, svgNamespace,
        "svg namespace inside an element inside a block is present" );
    });

    test("Block helper allows namespace to bleed through", function() {
      registerHelper('testing', function(params, hash, options, env) {
        var morph = options.morph;
        return options.template.render(this, env, morph.contextualElement);
      });

      var template = compile('<div><svg>{{#testing}}<circle />{{/testing}}</svg></div>');

      var fragment = template.render({ isTrue: true }, env);
      var svgNode = fragment.firstChild.firstChild;
      equal( svgNode.namespaceURI, svgNamespace,
             "svg tag has an svg namespace" );
      equal( svgNode.childNodes[0].namespaceURI, svgNamespace,
             "circle tag inside block inside svg has an svg namespace" );
    });

    test("Block helper with root svg allows namespace to bleed through", function() {
      registerHelper('testing', function(params, hash, options, env) {
        var morph = options.morph;
        return options.template.render(this, env, morph.contextualElement);
      });

      var template = compile('<svg>{{#testing}}<circle />{{/testing}}</svg>');

      var fragment = template.render({ isTrue: true }, env);
      var svgNode = fragment.firstChild;
      equal( svgNode.namespaceURI, svgNamespace,
             "svg tag has an svg namespace" );
      equal( svgNode.childNodes[0].namespaceURI, svgNamespace,
             "circle tag inside block inside svg has an svg namespace" );
    });

    test("Block helper with root foreignObject allows namespace to bleed through", function() {
      registerHelper('testing', function(params, hash, options, env) {
        var morph = options.morph;
        return options.template.render(this, env, morph.contextualElement);
      });

      var template = compile('<foreignObject>{{#testing}}<div></div>{{/testing}}</foreignObject>');

      var fragment = template.render({ isTrue: true }, env, document.createElementNS(svgNamespace, 'svg'));
      var svgNode = fragment.firstChild;
      equal( svgNode.namespaceURI, svgNamespace,
             "foreignObject tag has an svg namespace" );
      equal( svgNode.childNodes[0].namespaceURI, xhtmlNamespace,
             "div inside morph and foreignObject has xhtml namespace" );
    });

    }
  });
define("htmlbars-compiler-tests/html-compiler-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/html-compiler-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/html-compiler-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/htmlbars-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/fragment-javascript-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/fragment-javascript-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/fragment-javascript-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/fragment-opcode-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/fragment-opcode-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/fragment-opcode-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/hydration-javascript-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/hydration-javascript-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/hydration-javascript-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/hydration-opcode-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/hydration-opcode-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/hydration-opcode-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/template-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/template-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/template-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/template-visitor.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/template-visitor.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/template-visitor.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/utils.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/utils.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/utils.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/hydration-opcode-compiler-test",
  ["../htmlbars-compiler/hydration-opcode-compiler","../htmlbars-syntax/parser"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var HydrationOpcodeCompiler = __dependency1__["default"];
    var preprocess = __dependency2__.preprocess;

    function opcodesFor(html, options) {
      var ast = preprocess(html, options),
          compiler1 = new HydrationOpcodeCompiler(options);
      compiler1.compile(ast);
      return compiler1.opcodes;
    }

    QUnit.module("HydrationOpcodeCompiler opcode generation");

    test("simple example", function() {
      var opcodes = opcodesFor("<div>{{foo}} bar {{baz}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "shareElement", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], 0, 0, true ] ],
        [ "createMorph", [ 1, [ 0 ], 2, 2, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "pushLiteral", [ "baz" ] ],
        [ "printContentHook", [ 1 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("simple block", function() {
      var opcodes = opcodesFor("<div>{{#foo}}{{/foo}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], 0, 0, true ] ],
        [ "prepareObject", [ 0 ] ],
        [ "prepareArray", [ 0 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printBlockHook", [ 0, 0, null ] ],
        [ "popParent", [] ]
      ]);
    });

    test("simple block with block params", function() {
      var opcodes = opcodesFor("<div>{{#foo as |bar baz|}}{{/foo}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], 0, 0, true ] ],
        [ "prepareObject", [ 0 ] ],
        [ "prepareArray", [ 0 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printBlockHook", [ 0, 0, null ] ],
        [ "popParent", [] ]
      ]);
    });

    test("element with a sole mustache child", function() {
      var opcodes = opcodesFor("<div>{{foo}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], 0, 0, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("element with a mustache between two text nodes", function() {
      var opcodes = opcodesFor("<div> {{foo}} </div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], 1, 1, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("mustache two elements deep", function() {
      var opcodes = opcodesFor("<div><div>{{foo}}</div></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0, 0 ], 0, 0, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "popParent", [] ],
        [ "popParent", [] ]
      ]);
    });

    test("two sibling elements with mustaches", function() {
      var opcodes = opcodesFor("<div>{{foo}}</div><div>{{bar}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], 0, 0, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "popParent", [] ],
        [ "consumeParent", [ 1 ] ],
        [ "createMorph", [ 1, [ 1 ], 0, 0, true ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "printContentHook", [ 1 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("mustaches at the root", function() {
      var opcodes = opcodesFor("{{foo}} {{bar}}");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ ], 0, 0, true ] ],
        [ "createMorph", [ 1, [ ], 2, 2, true ] ],
        [ "openBoundary", [ ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "closeBoundary", [ ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "printContentHook", [ 1 ] ]
      ]);
    });

    test("back to back mustaches should have a text node inserted between them", function() {
      var opcodes = opcodesFor("<div>{{foo}}{{bar}}{{baz}}wat{{qux}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "shareElement", [ 0 ] ],
        [ "createMorph", [ 0, [0], 0, 0, true ] ],
        [ "createMorph", [ 1, [0], 1, 1, true ] ],
        [ "createMorph", [ 2, [0], 2, 2, true ] ],
        [ "createMorph", [ 3, [0], 4, 4, true] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHook", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "printContentHook", [ 1 ] ],
        [ "pushLiteral", [ "baz" ] ],
        [ "printContentHook", [ 2 ] ],
        [ "pushLiteral", [ "qux" ] ],
        [ "printContentHook", [ 3 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("helper usage", function() {
      var opcodes = opcodesFor("<div>{{foo 'bar' baz.bat true 3.14}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [0], 0, 0, true ] ],
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ 3.14 ] ],
        [ "pushLiteral", [ true ] ],
        [ "pushGetHook", [ "baz.bat" ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 4 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printInlineHook", [ 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("node mustache", function() {
      var opcodes = opcodesFor("<div {{foo}}></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "prepareObject", [ 0 ] ],
        [ "prepareArray", [ 0 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "shareElement", [ 0 ] ],
        [ "printElementHook", [ 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("node helper", function() {
      var opcodes = opcodesFor("<div {{foo 'bar'}}></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "shareElement", [ 0 ] ],
        [ "printElementHook", [ 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("attribute mustache", function() {
      var opcodes = opcodesFor("<div class='before {{foo}} after'></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "pushLiteral", [ " after" ] ],
        [ "pushGetHook", [ "foo" ] ],
        [ "pushLiteral", [ "before " ] ],
        [ "prepareArray", [ 3 ] ],
        [ "pushConcatHook", [ ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "createAttrMorph", [ 0, 0, "class", true, null ] ],
        [ "printAttributeHook", [ 0, 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("quoted attribute mustache", function() {
      var opcodes = opcodesFor("<div class='{{foo}}'></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "pushGetHook", [ "foo" ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushConcatHook", [ ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "createAttrMorph", [ 0, 0, "class", true, null ] ],
        [ "printAttributeHook", [ 0, 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("safe bare attribute mustache", function() {
      var opcodes = opcodesFor("<div class={{foo}}></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "pushGetHook", [ "foo" ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "createAttrMorph", [ 0, 0, "class", true, null ] ],
        [ "printAttributeHook", [ 0, 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("unsafe bare attribute mustache", function() {
      var opcodes = opcodesFor("<div class={{{foo}}}></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "pushGetHook", [ "foo" ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "createAttrMorph", [ 0, 0, "class", false, null ] ],
        [ "printAttributeHook", [ 0, 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("attribute helper", function() {
      var opcodes = opcodesFor("<div class='before {{foo 'bar'}} after'></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "pushLiteral", [ " after" ] ],
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "pushSexprHook", [ ] ],
        [ "pushLiteral", [ "before " ] ],
        [ "prepareArray", [ 3 ] ],
        [ "pushConcatHook", [ ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "createAttrMorph", [ 0, 0, "class", true, null ] ],
        [ "printAttributeHook", [ 0, 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("attribute helpers", function() {
      var opcodes = opcodesFor("<div class='before {{foo 'bar'}} after' id={{bare}}></div>{{morphThing}}<span class='{{ohMy}}'></span>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "shareElement", [ 0 ] ],
        [ "pushLiteral", [ " after" ] ],
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "pushSexprHook", [ ] ],
        [ "pushLiteral", [ "before " ] ],
        [ "prepareArray", [ 3 ] ],
        [ "pushConcatHook", [ ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "createAttrMorph", [ 0, 0, "class", true, null ] ],
        [ "printAttributeHook", [ 0, 0 ] ],
        [ "pushGetHook", [ 'bare' ] ],
        [ "pushLiteral", [ 'id' ] ],
        [ "createAttrMorph", [ 1, 0, 'id', true, null ] ],
        [ "printAttributeHook", [ 1, 0 ] ],
        [ "popParent", [] ],
        [ "createMorph", [ 0, [], 1, 1, true ] ],
        [ "pushLiteral", [ 'morphThing' ] ],
        [ "printContentHook", [ 0 ] ],
        [ "consumeParent", [ 2 ] ],
        [ "pushGetHook", [ 'ohMy' ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushConcatHook", [] ],
        [ "pushLiteral", [ 'class' ] ],
        [ "shareElement", [ 1 ] ],
        [ "createAttrMorph", [ 2, 1, 'class', true, null ] ],
        [ "printAttributeHook", [ 2, 1 ] ],
        [ "popParent", [] ]
      ]);
    });
  });
define("htmlbars-compiler-tests/hydration-opcode-compiler-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/hydration-opcode-compiler-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/hydration-opcode-compiler-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/template-compiler-test",
  ["../htmlbars-compiler/template-compiler","../htmlbars-syntax/parser","../htmlbars-test-helpers","../htmlbars-runtime/hooks","../htmlbars-runtime/helpers","../htmlbars-util/object-utils","../dom-helper"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__) {
    "use strict";
    var TemplateCompiler = __dependency1__["default"];
    var preprocess = __dependency2__.preprocess;
    var equalHTML = __dependency3__.equalHTML;
    var defaultHooks = __dependency4__["default"];
    var defaultHelpers = __dependency5__["default"];
    var merge = __dependency6__.merge;
    var DOMHelper = __dependency7__["default"];

    QUnit.module("TemplateCompiler");

    var dom, hooks, helpers;

    function countNamespaceChanges(template) {
      var ast = preprocess(template);
      var compiler = new TemplateCompiler();
      var program = compiler.compile(ast);
      var matches = program.match(/dom\.setNamespace/g);
      return matches ? matches.length : 0;
    }

    test("it works", function testFunction() {
      /* jshint evil: true */
      var ast = preprocess('<div>{{#if working}}Hello {{firstName}} {{lastName}}!{{/if}}</div>');
      var compiler = new TemplateCompiler();
      var program = compiler.compile(ast);
      var template = new Function("return " + program)();

      dom = new DOMHelper();
      hooks = merge({}, defaultHooks);
      helpers = merge({}, defaultHelpers);

      var env = {
        dom: dom,
        hooks: hooks,
        helpers: helpers
      };

      env.helpers['if'] = function(params, hash, options) {
        if (params[0]) {
          return options.template.render(context, env, options.morph.contextualElement);
        }
      };

      var context = {
        working: true,
        firstName: 'Kris',
        lastName: 'Selden'
      };
      var frag = template.render(context, env, document.body);
      equalHTML(frag, '<div>Hello Kris Selden!</div>');
    });

    test("it omits unnecessary namespace changes", function () {
      equal(countNamespaceChanges('<div></div>'), 0);  // sanity check
      equal(countNamespaceChanges('<div><svg></svg></div><svg></svg>'), 1);
      equal(countNamespaceChanges('<div><svg></svg></div><div></div>'), 2);
      equal(countNamespaceChanges('<div><svg><title>foobar</title></svg></div><svg></svg>'), 1);
      equal(countNamespaceChanges('<div><svg><title><h1>foobar</h1></title></svg></div><svg></svg>'), 3);
    });

    test('it adds the provided revision to the template', function () {
      var ast = preprocess('{{foo}}');
      var compiler = new TemplateCompiler({
        revision: 'FOO.BAR'
      });
      var program = compiler.compile(ast);

      ok(program.indexOf('revision: "FOO.BAR"') > -1);
    });
  });
define("htmlbars-compiler-tests/template-compiler-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/template-compiler-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/template-compiler-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/template-visitor-node-test",
  ["../htmlbars-syntax/parser","../htmlbars-compiler/template-visitor"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var preprocess = __dependency1__.preprocess;
    var TemplateVisitor = __dependency2__["default"];

    function actionsEqual(input, expectedActions) {
      var ast = preprocess(input);

      var templateVisitor = new TemplateVisitor();
      templateVisitor.visit(ast);
      var actualActions = templateVisitor.actions;

      // Remove the AST node reference from the actions to keep tests leaner
      for (var i = 0; i < actualActions.length; i++) {
        actualActions[i][1].shift();
      }

      deepEqual(actualActions, expectedActions);
    }

    QUnit.module("TemplateVisitor");

    test("empty", function() {
      var input = "";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['endProgram', [0]]
      ]);
    });

    test("basic", function() {
      var input = "foo{{bar}}<div></div>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['text', [0, 3]],
        ['mustache', [1, 3]],
        ['openElement', [2, 3, 0, []]],
        ['closeElement', [2, 3]],
        ['endProgram', [0]]
      ]);
    });

    test("nested HTML", function() {
      var input = "<a></a><a><a><a></a></a></a>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['openElement', [0, 2, 0, []]],
        ['closeElement', [0, 2]],
        ['openElement', [1, 2, 0, []]],
        ['openElement', [0, 1, 0, []]],
        ['openElement', [0, 1, 0, []]],
        ['closeElement', [0, 1]],
        ['closeElement', [0, 1]],
        ['closeElement', [1, 2]],
        ['endProgram', [0]]
      ]);
    });

    test("mustaches are counted correctly", function() {
      var input = "<a><a>{{foo}}</a><a {{foo}}><a>{{foo}}</a><a>{{foo}}</a></a></a>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['openElement', [0, 1, 2, []]],
        ['openElement', [0, 2, 1, []]],
        ['mustache', [0, 1]],
        ['closeElement', [0, 2]],
        ['openElement', [1, 2, 3, []]],
        ['openElement', [0, 2, 1, []]],
        ['mustache', [0, 1]],
        ['closeElement', [0, 2]],
        ['openElement', [1, 2, 1, []]],
        ['mustache', [0, 1]],
        ['closeElement', [1, 2]],
        ['closeElement', [1, 2]],
        ['closeElement', [0, 1]],
        ['endProgram', [0]]
      ]);
    });

    test("empty block", function() {
      var input = "{{#a}}{{/a}}";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['endProgram', [1]],
        ['startProgram', [1, []]],
        ['block', [0, 1]],
        ['endProgram', [0]]
      ]);
    });

    test("block with inverse", function() {
      var input = "{{#a}}b{{^}}{{/a}}";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['endProgram', [1]],
        ['startProgram', [0, []]],
        ['text', [0, 1]],
        ['endProgram', [1]],
        ['startProgram', [2, []]],
        ['block', [0, 1]],
        ['endProgram', [0]]
      ]);
    });

    test("nested blocks", function() {
      var input = "{{#a}}{{#a}}<b></b>{{/a}}{{#a}}{{b}}{{/a}}{{/a}}{{#a}}b{{/a}}";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['text', [0, 1]],
        ['endProgram', [1]],
        ['startProgram', [0, []]],
        ['mustache', [0, 1]],
        ['endProgram', [2]],
        ['startProgram', [0, []]],
        ['openElement', [0, 1, 0, []]],
        ['closeElement', [0, 1]],
        ['endProgram', [2]],
        ['startProgram', [2, []]],
        ['block', [0, 2]],
        ['block', [1, 2]],
        ['endProgram', [1]],
        ['startProgram', [2, []]],
        ['block', [0, 2]],
        ['block', [1, 2]],
        ['endProgram', [0]]
      ]);
    });

    test("component", function() {
      var input = "<x-foo>bar</x-foo>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['text', [0, 1]],
        ['endProgram', [1]],
        ['startProgram', [1, []]],
        ['component', [0, 1]],
        ['endProgram', [0]]
      ]);
    });

    test("comment", function() {
      var input = "<!-- some comment -->";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['comment', [0, 1]],
        ['endProgram', [0]]
      ]);
    });
  });
define("htmlbars-compiler-tests/template-visitor-node-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/template-visitor-node-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/template-visitor-node-test.js should pass jshint.'); 
    });
  });
define("htmlbars-runtime",
  ["htmlbars-runtime/hooks","htmlbars-runtime/helpers","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var hooks = __dependency1__["default"];
    var helpers = __dependency2__["default"];

    __exports__.hooks = hooks;
    __exports__.helpers = helpers;
  });
define("htmlbars-runtime.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('htmlbars-runtime.js should pass jshint', function() { 
      ok(true, 'htmlbars-runtime.js should pass jshint.'); 
    });
  });
define("htmlbars-runtime/helpers",
  ["exports"],
  function(__exports__) {
    "use strict";
    function partial(params, hash, options, env) {
      var template = env.partials[params[0]];
      return template.render(this, env, options.morph.contextualElement);
    }

    __exports__.partial = partial;__exports__["default"] = {
      partial: partial
    };
  });
define("htmlbars-runtime/helpers.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-runtime');
    test('htmlbars-runtime/helpers.js should pass jshint', function() { 
      ok(true, 'htmlbars-runtime/helpers.js should pass jshint.'); 
    });
  });
define("htmlbars-runtime/hooks",
  ["exports"],
  function(__exports__) {
    "use strict";
    function block(env, morph, context, path, params, hash, template, inverse) {
      var options = {
        morph: morph,
        template: template,
        inverse: inverse
      };

      var helper = lookupHelper(env, context, path);
      var value = helper.call(context, params, hash, options, env);

      morph.setContent(value);
    }

    __exports__.block = block;function inline(env, morph, context, path, params, hash) {
      var helper = lookupHelper(env, context, path);
      var value = helper.call(context, params, hash, { morph: morph }, env);

      morph.setContent(value);
    }

    __exports__.inline = inline;function content(env, morph, context, path) {
      var helper = lookupHelper(env, context, path);

      var value;
      if (helper) {
        value = helper.call(context, [], {}, { morph: morph }, env);
      } else {
        value = get(env, context, path);
      }

      morph.setContent(value);
    }

    __exports__.content = content;function element(env, domElement, context, path, params, hash) {
      var helper = lookupHelper(env, context, path);
      if (helper) {
        helper.call(context, params, hash, { element: domElement }, env);
      }
    }

    __exports__.element = element;function attribute(env, attrMorph, domElement, name, value) {
      attrMorph.setContent(value);
    }

    __exports__.attribute = attribute;function subexpr(env, context, helperName, params, hash) {
      var helper = lookupHelper(env, context, helperName);
      if (helper) {
        return helper.call(context, params, hash, {}, env);
      } else {
        return get(env, context, helperName);
      }
    }

    __exports__.subexpr = subexpr;function get(env, context, path) {
      if (path === '') {
        return context;
      }

      var keys = path.split('.');
      var value = context;
      for (var i = 0; i < keys.length; i++) {
        if (value) {
          value = value[keys[i]];
        } else {
          break;
        }
      }
      return value;
    }

    __exports__.get = get;function set(env, context, name, value) {
      context[name] = value;
    }

    __exports__.set = set;function component(env, morph, context, tagName, attrs, template) {
      var helper = lookupHelper(env, context, tagName);

      var value;
      if (helper) {
        var options = {
          morph: morph,
          template: template
        };

        value = helper.call(context, [], attrs, options, env);
      } else {
        value = componentFallback(env, morph, context, tagName, attrs, template);
      }

      morph.setContent(value);
    }

    __exports__.component = component;function concat(env, params) {
      var value = "";
      for (var i = 0, l = params.length; i < l; i++) {
        value += params[i];
      }
      return value;
    }

    __exports__.concat = concat;function componentFallback(env, morph, context, tagName, attrs, template) {
      var element = env.dom.createElement(tagName);
      for (var name in attrs) {
        element.setAttribute(name, attrs[name]);
      }
      element.appendChild(template.render(context, env, morph.contextualElement));
      return element;
    }

    function lookupHelper(env, context, helperName) {
      return env.helpers[helperName];
    }

    __exports__["default"] = {
      content: content,
      block: block,
      inline: inline,
      component: component,
      element: element,
      attribute: attribute,
      subexpr: subexpr,
      concat: concat,
      get: get,
      set: set
    };
  });
define("htmlbars-runtime/hooks.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-runtime');
    test('htmlbars-runtime/hooks.js should pass jshint', function() { 
      ok(true, 'htmlbars-runtime/hooks.js should pass jshint.'); 
    });
  });
define("htmlbars-test-helpers",
  ["exports"],
  function(__exports__) {
    "use strict";
    function equalInnerHTML(fragment, html) {
      var actualHTML = normalizeInnerHTML(fragment.innerHTML);
      QUnit.push(actualHTML === html, actualHTML, html);
    }

    __exports__.equalInnerHTML = equalInnerHTML;function equalHTML(node, html) {
      var fragment;
      if (!node.nodeType && node.length) {
        fragment = document.createDocumentFragment();
        while (node[0]) {
          fragment.appendChild(node[0]);
        }
      } else {
        fragment = node;
      }

      var div = document.createElement("div");
      div.appendChild(fragment.cloneNode(true));

      equalInnerHTML(div, html);
    }

    __exports__.equalHTML = equalHTML;// detect weird IE8 html strings
    var ie8InnerHTMLTestElement = document.createElement('div');
    ie8InnerHTMLTestElement.setAttribute('id', 'womp');
    var ie8InnerHTML = (ie8InnerHTMLTestElement.outerHTML.indexOf('id=womp') > -1);

    // detect side-effects of cloning svg elements in IE9-11
    var ieSVGInnerHTML = (function () {
      if (!document.createElementNS) {
        return false;
      }
      var div = document.createElement('div');
      var node = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      div.appendChild(node);
      var clone = div.cloneNode(true);
      return clone.innerHTML === '<svg xmlns="http://www.w3.org/2000/svg" />';
    })();

    function normalizeInnerHTML(actualHTML) {
      if (ie8InnerHTML) {
        // drop newlines in IE8
        actualHTML = actualHTML.replace(/\r\n/gm, '');
        // downcase ALLCAPS tags in IE8
        actualHTML = actualHTML.replace(/<\/?[A-Z\-]+/gi, function(tag){
          return tag.toLowerCase();
        });
        // quote ids in IE8
        actualHTML = actualHTML.replace(/id=([^ >]+)/gi, function(match, id){
          return 'id="'+id+'"';
        });
        // IE8 adds ':' to some tags
        // <keygen> becomes <:keygen>
        actualHTML = actualHTML.replace(/<(\/?):([^ >]+)/gi, function(match, slash, tag){
          return '<'+slash+tag;
        });

        // Normalize the style attribute
        actualHTML = actualHTML.replace(/style="(.+?)"/gi, function(match, val){
          return 'style="'+val.toLowerCase()+';"';
        });

      }
      if (ieSVGInnerHTML) {
        // Replace `<svg xmlns="http://www.w3.org/2000/svg" height="50%" />` with `<svg height="50%"></svg>`, etc.
        // drop namespace attribute
        actualHTML = actualHTML.replace(/ xmlns="[^"]+"/, '');
        // replace self-closing elements
        actualHTML = actualHTML.replace(/<([^ >]+) [^\/>]*\/>/gi, function(tag, tagName) {
          return tag.slice(0, tag.length - 3) + '></' + tagName + '>';
        });
      }

      return actualHTML;
    }

    __exports__.normalizeInnerHTML = normalizeInnerHTML;// detect weird IE8 checked element string
    var checkedInput = document.createElement('input');
    checkedInput.setAttribute('checked', 'checked');
    var checkedInputString = checkedInput.outerHTML;
    function isCheckedInputHTML(element) {
      equal(element.outerHTML, checkedInputString);
    }

    __exports__.isCheckedInputHTML = isCheckedInputHTML;// check which property has the node's text content
    var textProperty = document.createElement('div').textContent === undefined ? 'innerText' : 'textContent';
    function getTextContent(el) {
      // textNode
      if (el.nodeType === 3) {
        return el.nodeValue;
      } else {
        return el[textProperty];
      }
    }

    __exports__.getTextContent = getTextContent;// IE8 does not have Object.create, so use a polyfill if needed.
    // Polyfill based on Mozilla's (MDN)
    function createObject(obj) {
      if (typeof Object.create === 'function') {
        return Object.create(obj);
      } else {
        var Temp = function() {};
        Temp.prototype = obj;
        return new Temp();
      }
    }
    __exports__.createObject = createObject;
  });
define("htmlbars-test-helpers.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('htmlbars-test-helpers.js should pass jshint', function() { 
      ok(true, 'htmlbars-test-helpers.js should pass jshint.'); 
    });
  });
define("morph-attr",
  ["./morph-attr/sanitize-attribute-value","./dom-helper/prop","./dom-helper/build-html-dom","./htmlbars-util","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var sanitizeAttributeValue = __dependency1__.sanitizeAttributeValue;
    var isAttrRemovalValue = __dependency2__.isAttrRemovalValue;
    var normalizeProperty = __dependency2__.normalizeProperty;
    var svgNamespace = __dependency3__.svgNamespace;
    var getAttrNamespace = __dependency4__.getAttrNamespace;

    function updateProperty(value) {
      this.domHelper.setPropertyStrict(this.element, this.attrName, value);
    }

    function updateAttribute(value) {
      if (isAttrRemovalValue(value)) {
        this.domHelper.removeAttribute(this.element, this.attrName);
      } else {
        this.domHelper.setAttribute(this.element, this.attrName, value);
      }
    }

    function updateAttributeNS(value) {
      if (isAttrRemovalValue(value)) {
        this.domHelper.removeAttribute(this.element, this.attrName);
      } else {
        this.domHelper.setAttributeNS(this.element, this.namespace, this.attrName, value);
      }
    }

    function AttrMorph(element, attrName, domHelper, namespace) {
      this.element = element;
      this.domHelper = domHelper;
      this.namespace = namespace !== undefined ? namespace : getAttrNamespace(attrName);
      this.escaped = true;

      var normalizedAttrName = normalizeProperty(this.element, attrName);
      if (this.namespace) {
        this._update = updateAttributeNS;
        this.attrName = attrName;
      } else {
        if (element.namespaceURI === svgNamespace || attrName === 'style' || !normalizedAttrName) {
          this.attrName = attrName;
          this._update = updateAttribute;
        } else {
          this.attrName = normalizedAttrName;
          this._update = updateProperty;
        }
      }
    }

    AttrMorph.prototype.setContent = function (value) {
      if (this.escaped) {
        var sanitized = sanitizeAttributeValue(this.domHelper, this.element, this.attrName, value);
        this._update(sanitized, this.namespace);
      } else {
        this._update(value, this.namespace);
      }
    };

    __exports__["default"] = AttrMorph;

    __exports__.sanitizeAttributeValue = sanitizeAttributeValue;
  });
define("morph-attr.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('morph-attr.js should pass jshint', function() { 
      ok(true, 'morph-attr.js should pass jshint.'); 
    });
  });
define("morph-attr/sanitize-attribute-value",
  ["exports"],
  function(__exports__) {
    "use strict";
    /* jshint scripturl:true */

    var badProtocols = {
      'javascript:': true,
      'vbscript:': true
    };

    var badTags = {
      'A': true,
      'BODY': true,
      'LINK': true,
      'IMG': true,
      'IFRAME': true
    };

    var badAttributes = {
      'href': true,
      'src': true,
      'background': true
    };
    __exports__.badAttributes = badAttributes;
    function sanitizeAttributeValue(dom, element, attribute, value) {
      var tagName;

      if (!element) {
        tagName = null;
      } else {
        tagName = element.tagName;
      }

      if (value && value.toHTML) {
        return value.toHTML();
      }

      if ((tagName === null || badTags[tagName]) && badAttributes[attribute]) {
        var protocol = dom.protocolForURL(value);
        if (badProtocols[protocol] === true) {
          return 'unsafe:' + value;
        }
      }

      return value;
    }

    __exports__.sanitizeAttributeValue = sanitizeAttributeValue;
  });
define("morph-attr/sanitize-attribute-value.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - morph-attr');
    test('morph-attr/sanitize-attribute-value.js should pass jshint', function() { 
      ok(true, 'morph-attr/sanitize-attribute-value.js should pass jshint.'); 
    });
  });
define("morph-range",
  ["./morph-range/utils","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var clear = __dependency1__.clear;
    var insertBefore = __dependency1__.insertBefore;

    function Morph(domHelper, contextualElement) {
      this.domHelper = domHelper;
      // context if content if current content is detached
      this.contextualElement = contextualElement;

      // flag to force text to setContent to be treated as html
      this.parseTextAsHTML = false;

      this.firstNode = null;
      this.lastNode  = null;

      // morph graph
      this.parentMorph     = null;
      this.firstChildMorph = null;
      this.lastChildMorph  = null;

      this.previousMorph = null;
      this.nextMorph = null;
    }

    Morph.prototype.setContent = function Morph$setContent(content) {
      if (content === null || content === undefined) {
        return this.clear();
      }

      var type = typeof content;
      switch (type) {
        case 'string':
          if (this.parseTextAsHTML) {
            return this.setHTML(content);
          }
          return this.setText(content);
        case 'object':
          if (typeof content.nodeType === 'number') {
            return this.setNode(content);
          }
          /* Handlebars.SafeString */
          if (typeof content.string === 'string') {
            return this.setHTML(content.string);
          }
          if (this.parseTextAsHTML) {
            return this.setHTML(content.toString());
          }
          /* falls through */
        case 'boolean':
        case 'number':
          return this.setText(content.toString());
        default:
          throw new TypeError('unsupported content');
      }
    };

    Morph.prototype.clear = function Morph$clear() {
      return this.setNode(this.domHelper.createComment(''));
    };

    Morph.prototype.setText = function Morph$setText(text) {
      var firstNode = this.firstNode;
      var lastNode = this.lastNode;

      if (firstNode &&
          lastNode === firstNode &&
          firstNode.nodeType === 3) {
        firstNode.nodeValue = text;
        return firstNode;
      }

      return this.setNode(
        text ? this.domHelper.createTextNode(text) : this.domHelper.createComment('')
      );
    };

    Morph.prototype.setNode = function Morph$setNode(newNode) {
      var firstNode, lastNode;
      switch (newNode.nodeType) {
        case 3:
          firstNode = newNode;
          lastNode = newNode;
          break;
        case 11:
          firstNode = newNode.firstChild;
          lastNode = newNode.lastChild;
          if (firstNode === null) {
            firstNode = this.domHelper.createComment('');
            newNode.appendChild(firstNode);
            lastNode = firstNode;
          }
          break;
        default:
          firstNode = newNode;
          lastNode = newNode;
          break;
      }

      var previousFirstNode = this.firstNode;
      if (previousFirstNode !== null) {

        var parentNode = previousFirstNode.parentNode;
        insertBefore(parentNode, firstNode, lastNode, previousFirstNode);
        clear(parentNode, previousFirstNode, this.lastNode);
      }

      this.firstNode = firstNode;
      this.lastNode  = lastNode;

      if (this.parentMorph) {
        syncFirstNode(this);
        syncLastNode(this);
      }

      return newNode;
    };

    function syncFirstNode(_morph) {
      var morph = _morph;
      var parentMorph;
      while (parentMorph = morph.parentMorph) {
        if (morph !== parentMorph.firstChildMorph) {
          break;
        }
        if (morph.firstNode === parentMorph.firstNode) {
          break;
        }

        parentMorph.firstNode = morph.firstNode;

        morph = parentMorph;
      }
    }

    function syncLastNode(_morph) {
      var morph = _morph;
      var parentMorph;
      while (parentMorph = morph.parentMorph) {
        if (morph !== parentMorph.lastChildMorph) {
          break;
        }
        if (morph.lastNode === parentMorph.lastNode) {
          break;
        }

        parentMorph.lastNode = morph.lastNode;

        morph = parentMorph;
      }
    }

    // return morph content to an undifferentiated state
    // drops knowledge that the node has content.
    // this is for rerender, I need to test, but basically
    // the idea is to leave the content, but allow render again
    // without appending, so n
    Morph.prototype.reset = function Morph$reset() {
      this.firstChildMorph = null;
      this.lastChildMorph = null;
    };

    Morph.prototype.destroy = function Morph$destroy() {
      var parentMorph = this.parentMorph;
      var previousMorph = this.previousMorph;
      var nextMorph = this.nextMorph;
      var firstNode = this.firstNode;
      var lastNode = this.lastNode;
      var parentNode = firstNode && firstNode.parentNode;

      if (previousMorph) {
        if (nextMorph) {
          previousMorph.nextMorph = nextMorph;
          nextMorph.previousMorph = previousMorph;
        } else {
          previousMorph.nextMorph = null;
          if (parentMorph) { parentMorph.lastChildMorph = previousMorph; }
        }
      } else {
        if (nextMorph) {
          nextMorph.previousMorph = null;
          if (parentMorph) { parentMorph.firstChildMorph = nextMorph; }
        } else if (parentMorph) {
          parentMorph.lastChildMorph = parentMorph.firstChildMorph = null;
        }
      }

      this.parentMorph = null;
      this.firstNode = null;
      this.lastNode = null;

      if (parentMorph) {
        if (!parentMorph.firstChildMorph) {
          // list is empty
          parentMorph.clear();
          return;
        } else {
          syncFirstNode(parentMorph.firstChildMorph);
          syncLastNode(parentMorph.lastChildMorph);
        }
      }

      clear(parentNode, firstNode, lastNode);
    };

    Morph.prototype.setHTML = function(text) {
      var fragment = this.domHelper.parseHTML(text, this.contextualElement);
      return this.setNode(fragment);
    };

    Morph.prototype.appendContent = function(content) {
      return this.insertContentBeforeMorph(content, null);
    };

    Morph.prototype.insertContentBeforeMorph = function (content, referenceMorph) {
      var morph = new Morph(this.domHelper, this.contextualElement);
      morph.setContent(content);
      this.insertBeforeMorph(morph, referenceMorph);
      return morph;
    };

    Morph.prototype.appendMorph = function(morph) {
      this.insertBeforeMorph(morph, null);
    };

    Morph.prototype.insertBeforeMorph = function(morph, referenceMorph) {
      if (referenceMorph && referenceMorph.parentMorph !== this) {
        throw new Error('The morph before which the new morph is to be inserted is not a child of this morph.');
      }

      morph.parentMorph = this;

      var parentNode = this.firstNode.parentNode;

      insertBefore(
        parentNode,
        morph.firstNode,
        morph.lastNode,
        referenceMorph ? referenceMorph.firstNode : this.lastNode.nextSibling
      );

      // was not in list mode replace current content
      if (!this.firstChildMorph) {
        clear(parentNode, this.firstNode, this.lastNode);
      }

      var previousMorph = referenceMorph ? referenceMorph.previousMorph : this.lastChildMorph;
      if (previousMorph) {
        previousMorph.nextMorph = morph;
        morph.previousMorph = previousMorph;
      } else {
        this.firstChildMorph = morph;
      }

      if (referenceMorph) {
        referenceMorph.previousMorph = morph;
        morph.nextMorph = referenceMorph;
      } else {
        this.lastChildMorph = morph;
      }

      syncFirstNode(this.firstChildMorph);
      syncLastNode(this.lastChildMorph);
    };

    __exports__["default"] = Morph;
  });
define("morph-range.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('morph-range.js should pass jshint', function() { 
      ok(false, 'morph-range.js should pass jshint.\nmorph-range.js: line 119, col 41, Expected a conditional expression and instead saw an assignment.\nmorph-range.js: line 136, col 41, Expected a conditional expression and instead saw an assignment.\n\n2 errors'); 
    });
  });
define("morph-range.umd",
  ["./morph-range"],
  function(__dependency1__) {
    "use strict";
    var Morph = __dependency1__["default"];

    (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        define([], factory);
      } else if (typeof exports === 'object') {
        module.exports = factory();
      } else {
        root.Morph = factory();
      }
    }(this, function () {
      return Morph;
    }));
  });
define("morph-range.umd.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('morph-range.umd.js should pass jshint', function() { 
      ok(false, 'morph-range.umd.js should pass jshint.\nmorph-range.umd.js: line 4, col 39, \'define\' is not defined.\nmorph-range.umd.js: line 5, col 5, \'define\' is not defined.\nmorph-range.umd.js: line 7, col 5, \'module\' is not defined.\n\n3 errors'); 
    });
  });
define("morph-range/utils",
  ["exports"],
  function(__exports__) {
    "use strict";
    // inclusive of both nodes
    function clear(parentNode, firstNode, lastNode) {
      if (!parentNode) { return; }

      var node = firstNode;
      var nextNode;
      do {
        nextNode = node.nextSibling;
        parentNode.removeChild(node);
        if (node === lastNode) {
          break;
        }
        node = nextNode;
      } while (node);
    }

    __exports__.clear = clear;function insertBefore(parentNode, firstNode, lastNode, _refNode) {
      var node = lastNode;
      var refNode = _refNode;
      var prevNode;
      do {
        prevNode = node.previousSibling;
        parentNode.insertBefore(node, refNode);
        if (node === firstNode) {
          break;
        }
        refNode = node;
        node = prevNode;
      } while (node);
    }

    __exports__.insertBefore = insertBefore;
  });
define("morph-range/utils.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - morph-range');
    test('morph-range/utils.js should pass jshint', function() { 
      ok(true, 'morph-range/utils.js should pass jshint.'); 
    });
  });